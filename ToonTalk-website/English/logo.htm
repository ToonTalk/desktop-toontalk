<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 5.0">
<title>Is Logo old technology?</title>
<meta NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Office\HTML.DOT">
</head>

<body LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<p><em><font face="Comic Sans MS">The following discussion inspired me to write <a href="logottabs.htm">a paper on the topic</a> over 2 years later.</font></em></p>

<p><em><font face="Comic Sans MS">This is a discussion that was held on <font COLOR="#0000ff"><a HREF="news:comp.lang.logo">comp.lang.logo</a></font> (and the
corresponding email discussion list) from November 16 to December 2, 1998. The discussion
entitled &quot;Is <a href="http://el.www.media.mit.edu/logo-foundation/">Logo</a> old
technology?&quot; was started by the following message:</font></em></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">I recall an MIT Logo group meeting in 1977 where Seymour
Papert described Logo as an attempt to take the best ideas from computer science and make
them accessible to children. Most of those ideas had come from the Lisp programming
language. I think this was a wonderful choice when it was made 30 years ago. </font></p>

<p><font face="Comic Sans MS">Computer science has moved forward and Logo has barely
changed. Yes, LCSI Microworlds Logo adds some nice user interface gadgets and a very
impoverished way of running programs in parallel. (Concurrent programs can't really
synchronize and can only communicate via global variables.) StarLogo does borrow ideas
from computer science but its SIMD model of computation is not flexible enough for the
wide range of things that kids might want to program computers to do. It is a good thing
only when dealing with problems that are naturally &quot;data parallel&quot;. Object Logo
and Multi Logo were attempts to borrow from computer science object-oriented programming
and parallel processing respectively. But they didn't catch on. </font></p>

<p><font face="Comic Sans MS">Logo was a good attempt at &quot;child engineering&quot; the
ideas in Lisp. And more modern Logo implementations have kept up a bit by including menus,
buttons, mice, windows, and the like. But here Logo is just trying to catch up with
systems like Visual Basic. And both systems pale compared to the ease of use of user
interfaces in computer and video games. </font></p>

<p><font face="Comic Sans MS">During the last 20 years I have tried 4 times to make a new
and better programming system for kids that shares Logo's
pedagogic/epistimologic/constructivist view. Each time I tried to follow the original
design goals of Logo by &quot;child engineering&quot; the best ideas from computer
science. First I tried to introduce object-oriented programming (Smalltalk 72 was doing
the same thing but was a corporate secret at the time). Then logic programming. Then
visual programming. </font></p>

<p><font face="Comic Sans MS">ToonTalk (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)
is my most recent attempt. It is based upon what I call &quot;animated programming&quot;
where a child does all her programming by manipulating concrete objects inside of an
animated game-like world. ToonTalk is a general purpose language where a child programs by
training robots, giving birds messages to deliver, manipulating boxes, text pads, and
number pads, using animated tools, loading trucks and more. The child is a character in
this world and can even fly her helicopter to travel between houses or to see an overview
of an ongoing computation. </font></p>

<p><font face="Comic Sans MS">ToonTalk borrows ideas from computer science about how to
program with communicating independent processes. Everything happens in parallel in
ToonTalk. There are ways of expressing process spawning, communication, synchronization,
and termination. It also borrows from demonstrative and visual programming research. </font></p>

<p><font face="Comic Sans MS">Anecdotal evidence is that kids enjoy ToonTalk and master it
relatively quickly. (See <a HREF="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>)
A large pan-European research project just began on the first of the month that will be
building what they call &quot;playgrounds&quot; on top of ToonTalk and Logo. (See <a HREF="http://www.ioe.ac.uk/playground">www.ioe.ac.uk/playground</a>) They plan to do
careful studies of kids using both systems. I'm betting the ToonTalk half comes out ahead.
</font></p>

<p><font face="Comic Sans MS">I think Logo is a good thing - it is just that it could be
so much more than it is. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">I received a reply to my posting from Wen Su (<a HREF="mailto:wens@ncct.sps.mot.com">wens@ncct.sps.mot.com</a>) by email and with his
permission I am posting his message and my response to it. </font></p>

<p><font face="Comic Sans MS">Wen Su&nbsp; wrote: <br>
&gt;Should the new generation learn concurrent programming <br>
&gt;and declarative style programming only, totally skipping <br>
&gt;the &quot;traditional&quot; sequential programming? </font></p>

<p><font face="Comic Sans MS">&gt;This is a big question. If yes, ToonTalk's approach <br>
&gt;is definitely the way to go, no doubt about it. In my own <br>
&gt;opinion, it is easier for most people to adopt the declarative <br>
&gt;programming style than the concurrent programming style. <br>
&gt;For example, SQL, as used in data base, is declarative. <br>
&gt;It starts to be accepted universally these days. No people <br>
&gt;would say relational data base is slow today; people only <br>
&gt;cares about the &quot;productivity&quot; it has to offer. </font></p>

<p><font face="Comic Sans MS">This is the big question, I agree. I see value in kids
learning many different programming paradigms. Among them are </font></p>

<p><font face="Comic Sans MS">1. Concurrent object-oriented languages like ToonTalk. 2.
Sequential procedural languages like Logo. 3. Declarative or logic programming languages
like Prolog. (See Brian Harvey's recent posting. I should maybe clarify that while
ToonTalk has borrowed lots of ideas from logic programming, it doesn't have the nice query
and running programs backwards ability of Prolog that Brian described.) 4. Data
parallelism like StarLogo. 5. Others. Maybe pure functional programming. Or production
systems like Stagecast Creator (formerly known as KidSim and Cocoa). </font></p>

<p><font face="Comic Sans MS">While I think in the ideal world kids should learn all these
different ways of thinking about computation, the real world has limited resources. If I
had to prioritize these ways of thinking about programming I would stick to the order I
listed them above. Others might prefer other orderings. What criteria should we use to
decide this? Naturalness? Generality? Scalability? Elegance? Current popularity among
professional programmers? Popularity among computer scientists? Another question is which
one should be learned first? And which ones have the best chances of being useful for
understanding or solving problems in domains other than programming? </font></p>

<p><font face="Comic Sans MS">&gt;When I read a posting at your web site: &quot;Axiom 1:
the more <br>
&gt;you know about C/C++, the less you know about ToonTalk.&quot; <br>
&gt;I laugh but can not agree more at this. This reminds me of <br>
&gt;a saying back in those days when C++ and object C were just <br>
&gt;introduced: A person who likes Object C tends to dislike C++, <br>
&gt;and vice versa. I hope the similar thing won't happen for <br>
&gt;Logo and ToonTalk: A person who likes Logo tends to <br>
&gt;dislike ToonTalk, and vice versa. Just a joke here :-) </font></p>

<p><font face="Comic Sans MS">&gt;Seriously, though, I believe there is a force that is <br>
&gt;working behind this: Most &quot;average&quot; people tend to like what <br>
&gt;they have already known about, even though what they <br>
&gt;have already known about is not as good as the new one. <br>
&gt;If this is true, this works against the acceptance of <br>
&gt;ToonTalk because the constructs in Logo is more familiar <br>
&gt;to most people (esp. to the so-called technology teachers). <br>
&gt;On the other hand, ToonTalk may be more appeal to the <br>
&gt;children. If ToonTalk can be as fun as, say, SNES's Zelda LTP, <br>
&gt;or the Zelda-64 to be released in a week or two, it definitely <br>
&gt;could win the &quot;war.&quot; But those technology &quot;old dogs&quot; (maybe <br>
&gt;I am one of them because I am trained to be a C programmer) <br>
&gt;may be in the way and need to find a strategy to make them <br>
&gt;feel home at this new environment. </font></p>

<p><font face="Comic Sans MS">I agree most people like what they already know. This might
mean that teachers won't give ToonTalk the chance it deserves. But as you point out what
appeals to children is also important here. Nintendo SNES's Zelda was a source of ideas
and inspiration in building ToonTalk. I don't think I've come close to the charm and
appeal of that game, but I think I have come closer than any other &quot;educational&quot;
software that I know of. </font></p>

<p><font face="Comic Sans MS">&gt;This is just a thought from a newbie. I am still reading
<br>
&gt;the documents about ToonTalk at your web site and may <br>
&gt;decide to order one. My 10-year-old son has been familiar with <br>
&gt;MicroWorlds and I may want him to play with ToonTalk some day. <br>
&gt;Zelda LTP on SNES was his beloved game when he was about 7 (?). <br>
&gt;He is playing so-called RealTime strategy games on PC these days. </font></p>

<p><font face="Comic Sans MS">&gt;Regards, <br>
&gt;Wen Su </font></p>

<p><font face="Comic Sans MS">Thanks for your insightful comments. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ehud Lamm:</font></p>

<p><font face="Comic Sans MS">&quot;ToonTalk versus Logo&quot;. Before saying one more
word, I have to admit I didn't check the toontalk site yet. But...<br>
<br>
I once thought about doing alittle experiment and writing an article comparing how people
&quot;think&quot; with TIM (The Incredible Machine, computer game) and how they think with
Logo.<br>
<br>
I believe that aisde from all else, one of Logo's greatest strengths is that it is a
language. <br>
<br>
When I consider the way my thinking changed over the years, I think the most crucial point
was grasping the concept of ANGUAGE. This concept, and the intuitive feeling I have of it,
helped me in studiying CS and also in thinking about other issues. Logo was one of my
first exposures to language. Indeed, a computer language and not a human tongue, but none
the<br>
less a language where you have to try to put linear syntax on your ideas. A system in
which semantics are tied to syntax.<br>
<br>
I also think that being a computer language, Logo helps in giving a good method for
structuring algorithms into self contained parts, and building complex strucutures.<br>
<br>
I did look for other ideas (and there are many ideas in trying to find a better method for
programming a computer, than using a computer language), and was always dissatisfied. I
wanted the flexebility, genericity and elegance of Logo. <br>
<br>
I think that the great thing about Logo is that it is not really a protective enviroment.
It is REAL. You can get infinite loops, you can do harm. You have the real thing under
your hands. Kids shouldn't settle for less.<br>
<br>
(Note: This is not against ToonTalk, which as I said I know nothing about. Only general
comments about computer languages as superior to any other way of teaching kids through
computers).<br>
<br>
(Second note. This is somehow also connected to the theme of Hands-On Learning. A short
piece on this topic can be find in the archive on my web site.)<br>
<br>
Ehud Lamm <a HREF="mailto:mslamm@mscc.huji.ac.il">mslamm@mscc.huji.ac.il</a><br>
<a HREF="http://www2.cybercities.com/e/ehud">http://www2.cybercities.com/e/ehud</a> - Some
of the work a MISCologist.</font></p>

<p><font face="Comic Sans MS"><br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Ehud Lamm wrote in message ...<br>
&gt;I once thought about doing alittle experiment and writing an article<br>
&gt;comparing how people &quot;think&quot; with TIM (The Incredible Machine, computer<br>
&gt;game) and how they think with Logo.<br>
&gt;<br>
Sounds interesting. I'd read it if you wrote it.<br>
<br>
&gt;I believe that aisde from all else, one of Logo's greatest strengths is<br>
&gt;that it is a language.<br>
&gt;<br>
&gt;When I consider the way my thinking changed over the years, I think the<br>
&gt;most crucial point was grasping the concept of LANGUAGE. This concept, and<br>
&gt;the intuitive feeling I have of it, helped me in studiying CS and also in<br>
&gt;thinking about other issues. Logo was one of my first exposures to<br>
&gt;language. Indeed, a computer language and not a human tongue, but none the<br>
&gt;less a language where you have to try to put linear syntax on your ideas.<br>
&gt;A system in which semantics are tied to syntax.<br>
&gt;<br>
Here's maybe where we need some philosophers to jump in. For a while, sign language was
not accepted as a proper language - now it is. People talk about the language of film
(referring to the syntax of close-ups, cuts, dissolves, etc.). Is ToonTalk really a
language? Does it have a syntax, much less a linear one? I'm not sure that language is the
best word to describe ToonTalk, but I am sure it shares the nice properties that
programming languages have.<br>
<br>
&gt;I also think that being a computer language, Logo helps in giving a good<br>
&gt;method for structuring algorithms into self contained parts, and building<br>
&gt;complex strucutures.<br>
&gt;<br>
Ditto for ToonTalk.<br>
<br>
&gt;I did look for other ideas (and there are many ideas in trying to find a<br>
&gt;better method for programming a computer, than using a computer language),<br>
&gt;and was always dissatisfied. I wanted the flexebility, genericity and<br>
&gt;elegance of Logo.<br>
&gt;<br>
ToonTalk is flexible and generic. I think it is elegant too.<br>
<br>
&gt;I think that the great thing about Logo is that it is not really a<br>
&gt;protective enviroment. It is REAL. You can get infinite loops, you can do<br>
&gt;harm. You have the real thing under your hands. Kids shouldn't settle for<br>
&gt;less.<br>
&gt;<br>
I agree and ToonTalk is real in the same way that Logo is.<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ehud Lamm:</font></p>

<p><font face="Comic Sans MS">On Thu, 26 Nov 1998, Ken Kahn wrote:<br>
<br>
&gt; Ehud Lamm wrote in message ...<br>
&gt; &gt;I once thought about doing alittle experiment and writing an article<br>
&gt; &gt;comparing how people &quot;think&quot; with TIM (The Incredible Machine, computer<br>
&gt; &gt;game) and how they think with Logo.<br>
&gt; &gt;<br>
&gt; Sounds interesting. I'd read it if you wrote it.<br>
<br>
Maybe I'll have the time to write it. If I do - I'll let you know!<br>
<br>
&gt; <br>
&gt; &gt;I believe that aisde from all else, one of Logo's greatest strengths is<br>
&gt; &gt;that it is a language.<br>
&gt; &gt;<br>
&gt; &gt;When I consider the way my thinking changed over the years, I think the<br>
&gt; &gt;most crucial point was grasping the concept of LANGUAGE. This concept, and<br>
&gt; &gt;the intuitive feeling I have of it, helped me in studiying CS and also in<br>
&gt; &gt;thinking about other issues. Logo was one of my first exposures to<br>
&gt; &gt;language. Indeed, a computer language and not a human tongue, but none the<br>
&gt; &gt;less a language where you have to try to put linear syntax on your ideas.<br>
&gt; &gt;A system in which semantics are tied to syntax.<br>
&gt; &gt;<br>
&gt; Here's maybe where we need some philosophers to jump in. For a while, sign<br>
&gt; language was not accepted as a proper language - now it is. People talk<br>
&gt; about the language of film (referring to the syntax of close-ups, cuts,<br>
&gt; dissolves, etc.). Is ToonTalk really a language? Does it have a syntax, much<br>
&gt; less a linear one? I'm not sure that language is the best word to describe<br>
&gt; ToonTalk, but I am sure it shares the nice properties that programming<br>
&gt; languages have.<br>
<br>
Wll I do tend to see my self more as a philopher than any thing else (even<br>
though my field of work and studies was CS up till now).<br>
<br>
I will not try to define what a language is, since this really is a loaded<br>
question. But I do think some remakrs are inorder.<br>
<br>
Sign language was considered as a form of of non-verbal, lower than human<br>
communication, until hearing people tried to learn it, and found out it<br>
has the complexities of other languages. See Oliver Sack's book on this,<br>
and if you are interested in more details see Ursula Bellugi (speeling is<br>
wrong here, I am sure. Sorry)<br>
<br>
But it is none the less possible to clearly see when the term language is<br>
used litteraly and when it used metaphorically. &quot;The Language of Cinema&quot;<br>
is not the same as &quot;The language used in France&quot;. The concepts are not the<br>
same.<br>
<br>
What I'd consider important in a programming language is that it have a<br>
clear syntax (even when graphical) AND clear semantics. <br>
<br>
I'd also want some of the things we are accustomed to in programming<br>
languages, like support for common control structures (looping, branching,<br>
recursion), and data strctures (list are fine!)<br>
<br>
One of the basic features languages have is the ability to build complex<br>
structures from the ground up. You can use word in sentences, sentences in<br>
paragraphs etc etc. In prog. languages you can define procedures and use<br>
them in place of coding them again. I see theis aspect of managing thought<br>
(by defining &quot;concepts&quot;) and complexity highly important. I think it one<br>
of the basic things I learned from Logo. <br>
<br>
Ehud Lamm&nbsp;&nbsp;&nbsp;&nbsp; <a href="mailto:mslamm@mscc.huji.ac.il">mslamm@mscc.huji.ac.il</a><br>
<a href="http://www2.cybercities.com/e/ehud/">http://www2.cybercities.com/e/ehud/</a>
&nbsp;&nbsp;&nbsp; Subscribe to the E-List today!&nbsp; </font><br>
</p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Dale R. Reed:</font></p>

<p><font face="Comic Sans MS">&gt;I think Logo is a good thing - it is just that it could
be so much more than it is. </font></p>

<p><font face="Comic Sans MS">Ken, I just surfed to your site and ordered ToonTalk. </font></p>

<p><font face="Comic Sans MS">But I must admit that I(63 year old retired Electromagnetics
Engineer) am more interested in creating fractals and knots and moiré patterns and other
objects that I see in Mother Nature or imagine. And I don't think I have changed that much
on these accounts over the last 50 years. </font></p>

<p><font face="Comic Sans MS">I keep thinking about drawing knots with Logo just like I
used to think about the lightning currents that I was modeling and responsible for
protecting against as they redistributed(in frequency and time) through the graphite
composite and aluminum horizontal stabilizer of the being designed fly-by-wire 777.&nbsp;
The lightning currents in the past and now the knots and moiré patterns stir my mind
during restless nights sleeps. </font></p>

<p><font face="Comic Sans MS">I do not like games and I do not find Microworlds all that
much fun. It was OK when my little grandsonny lived nearby and he used to sit on my lap
and we would create imaginary worlds with dogs and trees and moons but he lives two hours
drive away now and growing up very quickly so what I want now is an efficient and powerful
way of creating my own designs. </font></p>

<p><font face="Comic Sans MS">Something that will force my mind to pay attention to detail
and offers me the capability to create something interesting that Katy and I can
enjoy.&nbsp; MSWLogo works just fine for my purposes.&nbsp; I bet I am not that much
different than many youngsters. </font></p>

<p><font face="Comic Sans MS">But Ken, I like new things and will give ToonTalk a
go.&nbsp;&nbsp;&nbsp; </font></p>

<p><font face="Comic Sans MS">Dale --- $ <a HREF="mailto:dale-reed@worldnet.att.net">dale-reed@worldnet.att.net</a>&nbsp;
Seattle, Washington U.S.A. $ </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ray Catzel:</font></p>

<p><font face="Comic Sans MS">I am an avid supporter of MicroWorlds because of the
outstanding success I have experienced enriching hundreds of kids over the past number of
years. </font></p>

<p><font face="Comic Sans MS">One of the great advantages of MicroWorlds is its ability to
bridge the gap between objects that are meaningful to children and program coding. You can
get away with minimal coding for the youngsters and provide very challenging (and more
abstract) projects for the older kids. </font></p>

<p><font face="Comic Sans MS">I took a brief look at toontalk and can't find the ability
to migrate smoothly from &quot;giving objects instructions&quot; to coding syntax. </font></p>

<p><font face="Comic Sans MS">I have no criticism of &quot;old&quot; technology if it is
stable and achieves learning objectives. Parallel, smarallel - do you really think the
child cares how the programs run in the background. </font></p>

<p><font face="Comic Sans MS">Have Fun! </font></p>

<p><font face="Comic Sans MS">Ray Catzel, President, ComputerPals Inc. </font></p>

<p><font face="Comic Sans MS">Web site: <a HREF="http://www.computerpals.on.ca/~pals">http://www.computerpals.on.ca/~pals</a>
</font></p>

<p><font face="Comic Sans MS">Email: <a HREF="mailto:learn@computerpals.on.ca">learn@computerpals.on.ca</a>
</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">RAY CATZEL wrote ... <br>
&gt;One of the great advantages of MicroWorlds is its ability to bridge the gap <br>
&gt;between objects that are meaningful to children and program coding. You can <br>
&gt;get away with minimal coding for the youngsters and provide very challenging <br>
&gt;(and more abstract) projects for the older kids. <br>
&gt; <br>
&gt;I took a brief look at toontalk and can't find the ability to migrate <br>
&gt;smoothly from &quot;giving objects instructions&quot; to coding syntax. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">I agree one wants software to span a wide range of abilities
and ambitions. I believe ToonTalk does this since one can just play with ToonTalk and
maybe put together some objects built by others or one can explore serious computer
science topics -- e.g. constructing a parallel quick sort program that is laid out so that
one can see the overall computation in a meaningful way. </font></p>

<p><font face="Comic Sans MS">But I don't put much value on &quot;coding syntax&quot;.
What I do value are the underlying concepts -- variables, recursion, data structures,
conditionals, etc. Turns out if you look really hard there is a way of bridging the gap
from ToonTalk to coding syntax. ToonTalk can generate a Java applet of whatever you have
programmed in ToonTalk. Effort was made so that the generated Java code is readable --
nice variables names, comments, etc. So there is a bridge to textual programming but I
don't see it as a vital component of ToonTalk. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;I have no criticism of &quot;old&quot; technology if it is stable and achieves <br>
&gt;learning objectives. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">And Jim Muller wrote: <br>
&gt;Fascinating statement...but you raise another question. Why does Logo have <br>
&gt;to be &quot;so much more than it is?&quot; </font></p>

<p><font face="Comic Sans MS"><br>
&gt;When you see the magic that Logo can add to a young child's self-literacy, <br>
&gt;what more could you ask for? </font></p>

<p><font face="Comic Sans MS">I can think of 2 answers: </font></p>

<p><font face="Comic Sans MS">1. A programming language is something &quot;to think
with&quot;. Thinking with sequential procedures and global variables is what Logo offers.
I've been thinking that way since I learned to program in 1968. But it was wonderful when
in 1973 I learned (mostly from an MIT professor named Carl Hewitt) to think in terms of
what he called actors -- concurrent objects with message passing. Then in 1980 I learned
from Prolog to think of programs declaratively in terms of predicates and theorem proving.
Concurrent Prolog and its sucessors taught me to think with both actors and logic
together. I won't claim that one way of thinking completely dominates the others. The Logo
way of thinking has its place. I just want to wake up the Logo community to the fact there
is much more that can be &quot;borrowed&quot; from computer science. </font></p>

<p><font face="Comic Sans MS">2. In 1994 I read an article by Sharon Yoder in Logo
Exchange entitled &quot;Discouraged? ... Don't dispair!&quot;. She asked a class of
college freshman about their exposure to Logo. A large percentage had been exposed and
nearly all reported it as a negative experience. In the 1970s I taught Logo and also saw
the results of teaching by others at the MIT Logo group. It was wonderful. It was
&quot;magic&quot;. My theory of how to reconcile these 2 facts is that kids can get a
tremendous amount from learning Logo if taught by a teacher who deeply understands both
kids and programming. I think Sharon's informal survey indicates that such teachers are
rare. </font></p>

<p><font face="Comic Sans MS">So how can we give kids the power and magic of programming
when such teachers aren't available? By making a software environment where kids can
discover and learn programming on their own. ToonTalk, I claim, is such an environment.
Kids can learn ToonTalk by exploring a safe self-revealing environment, by working their
way through an interactive puzzle game, by watching narrated demos, by getting help from a
software agent, and more. [I wrote a chapter in a book that was just published this month
on this topic. The book is The Design of Children's Technology, edited by Alison Druin,
published by Morgan Kaufmann]. Early indications are that this really works (see <a HREF="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>). </font></p>

<p><font face="Comic Sans MS">And Ray wrote: <br>
&gt; Parallel, smarallel - do you really think the child <br>
&gt;cares how the programs run in the background. </font></p>

<p><font face="Comic Sans MS">I think I have already partly answered this in point #1
above. But parallelism isn't just another tool of thinking, it is also a better way of
programming. For example, one of the demos in ToonTalk is the building of a Ping Pong
game. I am convinced that the best way to structure programs is as many independent (but
communicating and synchronizing) processes. In the Ping Pong example, the ball, the
paddle, and the score keeper are each parallel programs. The world around us is running in
parallel and trying to model or simulate it sequentially is unnecessarily difficult. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes: <br>
&gt;But I don't put much value on &quot;coding syntax&quot;. What I do value are the <br>
&gt;underlying concepts -- variables, recursion, data structures, conditionals, <br>
&gt;etc. </font></p>

<p><font face="Comic Sans MS">I agree with this, at this broad level of abstraction.&nbsp;
The question is what notation (broadly speaking) makes the ideas most accessible.&nbsp;
Something like a conditional can readily be represented pictorially.&nbsp; Recursion is a
little tougher, because (I think) in order to make something self-referential it has to
have a name.&nbsp; The best pictorial version I've seen is Radia Perlman's old &quot;slot
machine,&quot; in which the procedure names were colors, and were invoked by colored
cards.&nbsp; I find the BBN Function Machines attempt less compelling; you have to notice
that a box inside a box has the same name, which is really no better than text.&nbsp; I'll
be interested to see (tomorrow) how TT does it -- the documentation without the real
program left me quite confused. </font></p>

<p><font face="Comic Sans MS">I guess I think text gets a bum rap these days.&nbsp; We
used to have nothing but text, and everyone has overreacted.&nbsp; Text is still a really
expressive medium!&nbsp; Even for emotions, let alone computer programs. </font></p>

<p><font face="Comic Sans MS"><br>
&gt; Thinking with <br>
&gt;sequential procedures and global variables is what Logo offers. </font></p>

<p><font face="Comic Sans MS">Hey, no fair, Logo has local variables!&nbsp; But I do agree
that there are other valuable programming paradigms.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Jim Muller:</font></p>

<p><font face="Comic Sans MS">&gt;(snip) <br>
&gt; <br>
&gt;I think Logo is a good thing - it is just that it could be so much more than <br>
&gt;it is. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">Ken ==&gt; </font></p>

<p><font face="Comic Sans MS">Fascinating statement...but you raise another question. Why
does Logo have to be &quot;so much more than it is?&quot; </font></p>

<p><font face="Comic Sans MS">When you see the magic that Logo can add to a young child's
self-literacy, what more could you ask for? </font></p>

<p><font face="Comic Sans MS">Regards...Jim Muller </font></p>

<p><font face="Comic Sans MS">Jim Muller THE GREAT LOGO ADVENTURE at <a HREF="http://www.cyberramp.net/~jmul">http://www.cyberramp.net/~jmul</a> </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Dale R. Reed wrote <br>
&gt; <br>
&gt;Ken, I just surfed to your site and ordered ToonTalk. <br>
&gt; Thanks. I hope you enjoy it. <br>
&gt; <br>
&gt;I do not like games and I do not find Microworlds all that much fun. <br>
&gt;It was OK when my little grandsonny lived nearby and he used to sit on <br>
&gt;my lap and we would create imaginary worlds with dogs and trees and <br>
&gt;moons but he lives two hours drive away now and growing up very <br>
&gt;quickly so what I want now is an efficient and powerful way of <br>
&gt;creating my own designs. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">I used to enjoy games a lot before I discovered computer
programming. Programming is like a game only more challenging and more open-ended. While
designing ToonTalk, I found games to be a great source of ideas for how to make things
simpler or more fun without watering them down. </font></p>

<p><font face="Comic Sans MS">&gt;Something that will force my mind to pay attention to
detail and <br>
&gt;offers me the capability to create something interesting that Katy and <br>
&gt;I can enjoy.&nbsp; MSWLogo works just fine for my purposes.&nbsp; I bet I am not <br>
&gt;that much different than many youngsters. <br>
&gt; I think the ability &quot;to create something interesting&quot; is most important
thing about Logo and ToonTalk. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;But Ken, I like new things and will give ToonTalk a go. </font></p>

<p><font face="Comic Sans MS">That's a good attitude. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Bill Kerr:</font></p>

<p><font face="Comic Sans MS">Ken, Thanks for your interesting post about ToonTalk. I
probably won't have time to have a close look at it for a while but from the way you are
describing it I can't see a lot of difference from MicroWorlds or other LCSI products like
My Make Believe Castle (for younger kids). When you contrast ToonTalk with Logo you seem
to be referring to older (pre-MicroWorlds) versions of Logo. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;1. A programming language is something &quot;to think with&quot;. Thinking with <br>
&gt;sequential procedures and global variables is what Logo offers. I've been <br>
&gt;thinking that way since I learned to program in 1968. But it was wonderful <br>
&gt;when in 1973 I learned (mostly from an MIT professor named Carl Hewitt) to <br>
&gt;think in terms of what he called actors -- concurrent objects with message <br>
&gt;passing. </font></p>

<p><font face="Comic Sans MS">I have read Papert saying similar things, eg. in his
'Epistomological Pluralism' article (with Turkle) -- what you are describing is the
philosophy behind MicroWorlds. </font></p>

<p><font face="Comic Sans MS">Then in 1980 I learned from Prolog to think of programs <br>
&gt;declaratively in terms of predicates and theorem proving. Concurrent Prolog <br>
&gt;and its sucessors taught me to think with both actors and logic together. I <br>
&gt;won't claim that one way of thinking completely dominates the others. The <br>
&gt;Logo way of thinking has its place. I just want to wake up the Logo <br>
&gt;community to the fact there is much more that can be &quot;borrowed&quot; from <br>
&gt;computer science. </font></p>

<p><font face="Comic Sans MS">the idea of building both logic and intuition into software,
catering for a diversity of learning styles, is also a Papert idea (eg. same article) and
I think this is part of the MicroWorlds design. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;2. In 1994 I read an article by Sharon Yoder in Logo Exchange entitled <br>
&gt;&quot;Discouraged? ... Don't dispair!&quot;. She asked a class of college freshman <br>
&gt;about their exposure to Logo. A large percentage had been exposed and nearly <br>
&gt;all reported it as a negative experience. In the 1970s I taught Logo and <br>
&gt;also saw the results of teaching by others at the MIT Logo group. It was <br>
&gt;wonderful. It was &quot;magic&quot;. My theory of how to reconcile these 2 facts is <br>
&gt;that kids can get a tremendous amount from learning Logo if taught by a <br>
&gt;teacher who deeply understands both kids and programming. I think Sharon's <br>
&gt;informal survey indicates that such teachers are rare. </font></p>

<p><font face="Comic Sans MS">I agree with your analysis here. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;So how can we give kids the power and magic of programming when such <br>
&gt;teachers aren't available? By making a software environment where kids can <br>
&gt;discover and learn programming on their own. ToonTalk, I claim, is such an <br>
&gt;environment. Kids can learn ToonTalk by exploring a safe self-revealing <br>
&gt;environment, by working their way through an interactive puzzle game, by <br>
&gt;watching narrated demos, by getting help from a software agent, and more. [I <br>
&gt;wrote a chapter in a book that was just published this month on this topic. <br>
&gt;The book is The Design of Children's Technology, edited by Alison Druin, <br>
&gt;published by Morgan Kaufmann]. Early indications are that this really works <br>
&gt;(see <a HREF="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>).
</font></p>

<p><font face="Comic Sans MS">This argument is both true and dangerous IMO. Good
constructionist software will be more intuitive for new users (true) but there will always
be a place for good teachers to find diverse ways to take the user to a higher level. To
suggest this might happen through the software alone is dangerous. (I'd like to chase up
your chapter but no time right now). I think a better solution to the dilemma is to
improve teacher education courses because the human factor will always be the most
important one. </font></p>

<p><font face="Comic Sans MS">&gt;And Ray wrote: <br>
&gt;&gt; Parallel, smarallel - do you really think the child <br>
&gt;&gt;cares how the programs run in the background. </font></p>

<p><font face="Comic Sans MS">&gt; <br>
&gt;I think I have already partly answered this in point #1 above. But <br>
&gt;parallelism isn't just another tool of thinking, it is also a better way of <br>
&gt;programming. For example, one of the demos in ToonTalk is the building of a <br>
&gt;Ping Pong game. I am convinced that the best way to structure programs is as <br>
&gt;many independent (but communicating and synchronizing) processes. In the <br>
&gt;Ping Pong example, the ball, the paddle, and the score keeper are each <br>
&gt;parallel programs. The world around us is running in parallel and trying to <br>
&gt;model or simulate it sequentially is unnecessarily difficult. </font></p>

<p><font face="Comic Sans MS">I think what Ray meant is that MicroWorlds also support
parallelism. What you need to show is that TuneTalk somehow does it better, ie. the
difference is somehow obvious to the user not just to a sophisticated computer scientist.
(although I'd be interested in either explanation personally, ie. an expansion of your
earlier very brief explanation). </font></p>

<p><font face="Comic Sans MS">I'm interested in finding out more about TuneTalk and its
educational philosophy. These brief comments might help you address some of the thinking
you will find in this newsgroup. </font></p>

<p><font face="Comic Sans MS">-- Bill Kerr </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Gary S. Stager:</font></p>

<p><font face="Comic Sans MS">Brian, </font></p>

<p><font face="Comic Sans MS">I had a powerful experience yesterday trying to use a new
&quot;easier&quot; programming environment for kids. Although I was attempting a very
simple task, the clumsiness of the interface required me to call an old colleague who
works for the company that produces the stuff. The two of us then spent the next hour
trying to collaborate on what should have been a 2 minute program because there was no
language for communicating about our program. &quot;Connect the blue thingy to the corner
of the icon - no not that corner - I said the merge fork...&quot; </font></p>

<p><font face="Comic Sans MS">One of the powerful ideas of Logo is that it's sharable.
I've recently been reminded of its power by a student of mine who teaches little Latino
kids in L.A. These 3rd grade limited-English speaking kids are deconstructing projects
created by rich NY private middle school kids and programming (or at least feeling
sufficiently confident that they can attempt to program) their own videogames. Logo offers
kids an environment in which they can create something sharable very early in their use of
the software because it allows for multiple approaches to solving a problem. </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Gary S. Stager wrote <br>
&gt;I had a powerful experience yesterday trying to use a new &quot;easier&quot; <br>
&gt;programming environment for kids. Although I was attempting a very simple <br>
&gt;task, the clumsiness of the interface required me to call an old <br>
&gt;colleague who works for the company that produces the stuff. The two of <br>
&gt;us then spent the next hour trying to collaborate on what should have <br>
&gt;been a 2 minute program because there was no language for communicating <br>
&gt;about our program. &quot;Connect the blue thingy to the corner of the icon - <br>
&gt;no not that corner - I said the merge fork...&quot; <br>
&gt; <br>
&gt;One of the powerful ideas of Logo is that it's sharable. ... </font></p>

<p><font face="Comic Sans MS">Some things like, Logo, are easier to talk about on a
telephone or by email. Not surprising since Logo is textual. Other things like the
software you were using, ToonTalk, and knots are not so well-suited for purely verbal
discussions. Minsky and Papert once tried to &quot;share&quot; knots over a telephone.
They found it extremely difficult. </font></p>

<p><font face="Comic Sans MS">If you and your colleague had a way to link your computers
so you both saw the same screen and maybe you both had a mouse cursor for pointing, then
talking on the phone might have been very productive. </font></p>

<p><font face="Comic Sans MS">But sharability isn't the same as being able to talk about
them on the phone. Things you make in ToonTalk are sharable - you can even put them in
email messages or convert them to Java applets to show anyone with a web browser what you
have made. And these things are composable -- a very very important feature. Sequential
Logo is composable as well - but I worry how well Microworlds parallel processes compose
if communication is via global variables. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From <a HREF="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a>:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes: [snip] <br>
&gt; If you and your colleague had a way to link your computers so you both saw <br>
&gt; the same screen and maybe you both had a mouse cursor for pointing, then <br>
&gt; talking on the phone might have been very productive. </font></p>

<p><font face="Comic Sans MS">vnc is such a piece of software... <a HREF="http://www.orl.co.uk/vnc/">http://www.orl.co.uk/vnc/</a> </font></p>

<p><font face="Comic Sans MS">and, like most good software, it's Open Source. </font></p>

<p><font face="Comic Sans MS">andru</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Bill Kerr&quot; &lt;<a HREF="mailto:kerrb@senet.com.au">kerrb@senet.com.au</a>&gt; writes: <br>
&gt; Then in 1980 I learned from Prolog to think of programs <br>
&gt;&gt;declaratively in terms of predicates and theorem proving. Concurrent Prolog <br>
&gt;&gt;and its sucessors taught me to think with both actors and logic together. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;the idea of building both logic and intuition into software, catering for a <br>
&gt;diversity of learning styles, is also a Papert idea (eg. same article) and I <br>
&gt;think this is part of the MicroWorlds design. </font></p>

<p><font face="Comic Sans MS">This isn't quite fair.&nbsp; Any programming language
requires logical thinking, but Logic Programming is still very different from procedural
programming. The shift in thought processes that's required is of the same order (though
in a different direction) as the degree to which the massive parallelism in StarLogo is
hugely different from traditional programming, and even from the limited parallelism in
Microworlds. </font></p>

<p><font face="Comic Sans MS">Ken's quite right that there's nothing in any flavor of Logo
remotely like logic programming.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">Bill Kerr wrote <br>
&gt; Thanks for your interesting post about ToonTalk. I probably won't have time <br>
&gt;to have a close look at it for a while but from the way you are describing <br>
&gt;it I can't see a lot of difference from MicroWorlds or other LCSI products <br>
&gt;like My Make Believe Castle (for younger kids). When you contrast ToonTalk <br>
&gt;with Logo you seem to be referring to older (pre-MicroWorlds) versions of <br>
&gt;Logo. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">From the point of view of a computer scientist there are
very big differences. They differ both in syntax and semantics. Logo has a textual syntax.
ToonTalk has an animated visual syntax. Logo is a sequential procedural language. ToonTalk
is a concurrent object-oriented language.&nbsp; My Make Believe Castle is a bit more like
ToonTalk but it is not a general purpose programming language. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;&gt;1. A programming language is something &quot;to think with&quot;. Thinking with <br>
&gt;&gt;sequential procedures and global variables is what Logo offers. I've been <br>
&gt;&gt;thinking that way since I learned to program in 1968. But it was wonderful <br>
&gt;&gt;when in 1973 I learned (mostly from an MIT professor named Carl Hewitt) to <br>
&gt;&gt;think in terms of what he called actors -- concurrent objects with message <br>
&gt;&gt;passing. <br>
&gt; <br>
&gt;I have read Papert saying similar things, eg. in his 'Epistomological <br>
&gt;Pluralism' article (with Turkle) -- what you are describing is the <br>
&gt;philosophy behind MicroWorlds. <br>
&gt; I've learned a lot from Seymour - including this idea. Maybe I'm mistaken, but
Microworlds doesn't really change Logo that much. It adds lots of useful user interface
gadgets and a very primitive, impoverished notion of parallel processing. I am not aware
of any way to synchronize parallel processes in Microworlds. And the only way processes
can communicate is via global variables. This is poor modularity and can lead to extremely
hard to track down bugs. And in what sense is Microworlds object-oriented? </font></p>

<p><font face="Comic Sans MS"><br>
&gt; <br>
&gt;the idea of building both logic and intuition into software, catering for a <br>
&gt;diversity of learning styles, is also a Papert idea (eg. same article) and I <br>
&gt;think this is part of the MicroWorlds design. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">Logic/planning and intuition/tinkering are in that article.
And I don't question that Microworlds supports both cognitive styles (as does ToonTalk).
But that is a different level than what I was trying to get at. I was pointing out there
is a role for logic and declarative thinking as a way of EXPRESSING programs, not just
designing and building them. </font></p>

<p><font face="Comic Sans MS">&gt; <br>
&gt;This argument is both true and dangerous IMO. Good constructionist software <br>
&gt;will be more intuitive for new users (true) but there will always be a place <br>
&gt;for good teachers to find diverse ways to take the user to a higher level. <br>
&gt;To suggest this might happen through the software alone is dangerous. (I'd <br>
&gt;like to chase up your chapter but no time right now). I think a better <br>
&gt;solution to the dilemma is to improve teacher education courses because the <br>
&gt;human factor will always be the most important one. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">I agree to an extent. But I also see ToonTalk working in the
home where there is no teacher. Seymour's most recent book &quot;The Connected
Family&quot;&nbsp; also emphasizes the learning that happens at home. </font></p>

<p><font face="Comic Sans MS"><br>
&gt; <br>
&gt;I think what Ray meant is that MicroWorlds also support parallelism. What <br>
&gt;you need to show is that TuneTalk somehow does it better, ie. the difference <br>
&gt;is somehow obvious to the user not just to a sophisticated computer <br>
&gt;scientist. (although I'd be interested in either explanation personally, ie. <br>
&gt;an expansion of your earlier very brief explanation). <br>
&gt; </font></p>

<p><font face="Comic Sans MS">I touched on the sophisticated computer scientist answer
above. I plan to write 1 or 2 page long answer to this soon and will post it when it is
ready. </font></p>

<p><font face="Comic Sans MS"><br>
&gt;I'm interested in finding out more about TuneTalk and its educational <br>
&gt;philosophy. These brief comments might help you address some of the thinking <br>
&gt;you will find in this newsgroup. <br>
&gt; Your comments were helpful, thanks. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Bill Kerr:</font></p>

<p><font face="Comic Sans MS">Brian wrote: <br>
&gt;Ken's quite right that there's nothing in any flavor of Logo remotely like <br>
&gt;logic programming. </font></p>

<p><font face="Comic Sans MS">I know nothing about Prologo so I stand corrected. My
question would be: what is it about ToonTalk&nbsp; logic that is both obvious and superior
to the logic of MicroWorlds? Is this a powerful idea like recursion that ought to be
incorporated into educational software and that its exclusion make Logo &quot;old
technology&quot;? Or is it something which is mainly of interest to computer scientists
but not to a wider audience? My (admittedly subjective) feeling is that the balance
between logic and intuition in MicroWorlds is about right. </font></p>

<p><font face="Comic Sans MS">-- Bill Kerr </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Bill Kerr&quot; &lt;<a HREF="mailto:kerrb@senet.com.au">kerrb@senet.com.au</a>&gt; writes: <br>
&gt;Brian wrote: <br>
&gt;&gt;Ken's quite right that there's nothing in any flavor of Logo remotely like <br>
&gt;&gt;logic programming. <br>
&gt; <br>
&gt;I know nothing about Prologo so I stand corrected. My question would be: <br>
&gt;what is it about ToonTalk&nbsp; logic that is both obvious and superior to the <br>
&gt;logic of MicroWorlds? Is this a powerful idea like recursion that ought to <br>
&gt;be incorporated into educational software and that its exclusion make Logo <br>
&gt;&quot;old technology&quot;? Or is it something which is mainly of interest to computer
<br>
&gt;scientists but not to a wider audience? My (admittedly subjective) feeling <br>
&gt;is that the balance between logic and intuition in MicroWorlds is about <br>
&gt;right. </font></p>

<p><font face="Comic Sans MS">First of all, forget about that &quot;balance between logic
and intuition&quot; business.&nbsp; Logic programming involves neither more nor less
intuition than procedural programming. </font></p>

<p><font face="Comic Sans MS">In procedural programming, you tell the computer an
ALGORITHM it will use to compute the answers you want.&nbsp; First do this, then do that,
etc. </font></p>

<p><font face="Comic Sans MS">In logic programming, you tell the computer some FACTS that
you know, and some RULES that can be used to infer new facts, and then you ask it
questions, and it's the computer's job to figure out how to get the answers. </font></p>

<p><font face="Comic Sans MS">As a classic example, here is a Logo procedure to append two
lists: </font></p>

<p><font face="Comic Sans MS">to append :a :b if empty? :a [output :b] output fput (first
:a) (append bf :a :b) end </font></p>

<p><font face="Comic Sans MS">By contrast, in logic programming you would enter these
rules: </font></p>

<p><font face="Comic Sans MS">(append [] :b) = :b </font></p>

<p><font face="Comic Sans MS">IF (append :a :b) = :c THEN (append (fput :x :a) :b) = (fput
:x :c) </font></p>

<p><font face="Comic Sans MS">(This isn't really any particular logic language; I'm trying
to use Logo vocabulary and notation to avoid making notation an issue.) With these rules,
as with a Logo procedure, you can as questions like </font></p>

<p><font face="Comic Sans MS">What is (append [1 2 3] [4 5])? </font></p>

<p><font face="Comic Sans MS">but you can also ask questions like </font></p>

<p><font face="Comic Sans MS">If (append [1 2 3] :x) is [1 2 3 4 5], what is :x? </font></p>

<p><font face="Comic Sans MS">or even </font></p>

<p><font face="Comic Sans MS">If (append :x :y) is [1 2 3 4 5], what are :x and :y? </font></p>

<p><font face="Comic Sans MS">which will give you all six possible answers!&nbsp; In Logo,
you can't &quot;run a procedure backwards&quot; as you can the rules in a logic language. </font></p>

<p><font face="Comic Sans MS">The way it works is that the inventors of logic programming
invented a sort of universal algorithm, a generalization of pattern matching. </font></p>

<p><font face="Comic Sans MS">Logic programming is a natural fit for data base querying;
it's less obvious as a fit for side-effect-laden programming, although many years ago Ken
Kahn wrote a turtle graphics package in Prolog, so his current interests have a long
history. </font></p>

<p><font face="Comic Sans MS">Logic programming really is quite a different way of
thinking about programming, and it does, I think, stretch the mind usefully, whether or
not one is a computer scientist.&nbsp; Using Prolog as a first language for kids has a
pretty long history, not in the US but definitely in England -- Richard Ennals wrote a
Prolog-for-kids book, I think some time in the 1970s but all my books are still in cartons
so I can't look it up right now.&nbsp; (I just moved!) </font></p>

<p><font face="Comic Sans MS">Executive summary:&nbsp; I don't think Logo is *obsolete*,
but I do think that there are more than one good computer tool for kids!</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Bill Kerr:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote: <br>
&gt;Logic programming really is quite a different way of thinking about <br>
&gt;programming, and it does, I think, stretch the mind usefully, whether <br>
&gt;or not one is a computer scientist.&nbsp; Using Prolog as a first language <br>
&gt;for kids has a pretty long history, not in the US but definitely in <br>
&gt;England -- Richard Ennals wrote a Prolog-for-kids book, </font></p>

<p><font face="Comic Sans MS">Thanks for your informative response -- it sounds like
Prolog might be a good way to give meaning to the concept of reverse engineering. </font></p>

<p><font face="Comic Sans MS">-- Bill Kerr </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Bill Kerr:</font></p>

<p><font face="Comic Sans MS">Ken Kahn wrote:<br>
&gt; Maybe I'm mistaken,<br>
&gt;but Microworlds doesn't really change Logo that much. It adds lots of useful<br>
&gt;user interface gadgets and a very primitive, impoverished notion of parallel<br>
&gt;processing. I am not aware of any way to synchronize parallel processes in<br>
&gt;Microworlds.<br>
<br>
I think this MicroWorlds procedure (from MW help on waituntil and also done?) does
synchronise parallel processes:<br>
<br>
to sq-circ<br>
t1, pd launch [repeat 36 [fd 10 rt 10]]<br>
; t1 draws a circle<br>
t2, pd launch [repeat 4 [fd 50 rt 90]]<br>
; t2 draws a square<br>
waituntil [done? [repeat 36 [fd 10 rt 10]]]<br>
; the procedure does not continue until the circle is finished<br>
; so that the drawings of circles and square are synchronised<br>
t1, pu rt random 360 fd random 50<br>
t2, pu rt random 360 fd random 50<br>
; repositions turtles for next drawing<br>
sq-circ<br>
end<br>
<br>
&gt;And the only way processes can communicate is via global<br>
&gt;variables. This is poor modularity and can lead to extremely hard to track<br>
&gt;down bugs. And in what sense is Microworlds object-oriented?<br>
<br>
MicroWorlds has a turtlesown primitive that enables you to localise things like the speed
or reset position of a turtle which is, for instance, simulating a horse. I'll paste in
the MW help explanation here, which will give us some sort of starting point for further
discussion. I'm not trying to suggest that MW is fully object orientated but code can
reside on objects such as colours, turtles, buttons. This gives students an introduction
to elementary oops concepts and for young kids I can't see the point in going beyond that.
MW and logo has local variables which would be the main thing, wouldn't it? My main
impression from doing a little bit of java oops earlier this year is that everything is 10
times harder than in using logo.<br>
<br>
&lt;start of paste from MW help&gt;<br>
turtlesown word<br>
<br>
Assigns a variable to all the turtles in the current project. This variable can then be
set to a specific value for each turtle. This command also creates a new primitive made of
the word set followed by the name of the variable (e.g., turtlesown &quot;speed creates a
setspeed command as in t1, setspeed 12). There are two ways to get the value of a given
turtle variable: you can talk to a turtle and use the variable name to report the value
(e.g., t1, show speed displays 12 in this example) or you can use the turtle name followed
by 's (e.g., show t1's &quot;speed displays 12).<br>
<br>
Use remove to remove a turtle variable. This removes the named variable for all the
turtles in the project. After a turtlesown instruction, the value of the variable is set
to the empty list (see the first three lines in the example below).<br>
Example:<br>
<br>
turtlesown &quot;speed<br>
t1, show speed<br>
(empty list)<br>
t1, setspeed 10<br>
t2, setspeed 20<br>
t3, setspeed 5<br>
t1, show speed<br>
10<br>
show t2's &quot;speed<br>
20<br>
everyone [fd speed]<br>
everyone [forever [fd speed]]<br>
<br>
Choose Stop All from the Edit menu.<br>
<br>
remove &quot;speed<br>
&lt;end of paste from MW help&gt;<br>
<br>
-- Bill Kerr<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Bill Kerr wrote in message
&lt;000201be183d$78328100$9cfc98cb@kerrb&gt;...<br>
&gt;Ken Kahn wrote:<br>
&gt;&gt;I am not aware of any way to synchronize parallel processes in Microworlds.<br>
&gt;<br>
&gt;I think this MicroWorlds procedure (from MW help on waituntil and also<br>
&gt;done?) does synchronise parallel processes:<br>
&gt;<br>
&gt;to sq-circ<br>
&gt;t1, pd launch [repeat 36 [fd 10 rt 10]]<br>
&gt;; t1 draws a circle<br>
&gt;t2, pd launch [repeat 4 [fd 50 rt 90]]<br>
&gt;; t2 draws a square<br>
&gt;waituntil [done? [repeat 36 [fd 10 rt 10]]]<br>
&gt;; the procedure does not continue until the circle is finished<br>
&gt;; so that the drawings of circles and square are synchronised<br>
&gt;t1, pu rt random 360 fd random 50<br>
&gt;t2, pu rt random 360 fd random 50<br>
&gt;; repositions turtles for next drawing<br>
&gt;sq-circ<br>
&gt;end<br>
&gt;<br>
<br>
I stand corrected, thanks. This is a kind of control flow synchronization since it waits
until the processes spawned for t1 and t2 have terminated. Or does &quot;waituntil
[done?&quot; wait until all processes have terminated? Does MicroWorlds also have process
synchronization based upon data? So, for example, a consumer process of some data waits
until the generator has generated it? Note that in general the generator need not have
terminated, it may just be reporting back results as it finds them (e.g. a web search
engine). ToonTalk only has data synchronization but that is the more general kind of
synchronization, since one can set data (in ToonTalk give a bird a token) indicating that
the process is just terminating.<br>
<br>
By the way, is there a MicroWorlds manual on the web somewhere?<br>
<br>
&gt;&gt;And the only way processes can communicate is via global<br>
&gt;&gt;variables. This is poor modularity and can lead to extremely hard to track<br>
&gt;&gt;down bugs. And in what sense is Microworlds object-oriented?<br>
&gt;<br>
&gt;<br>
&gt;MicroWorlds has a turtlesown primitive that enables you to localise things<br>
&gt;like the speed or reset position of a turtle which is, for instance,<br>
&gt;simulating a horse. I'll paste in the MW help explanation here, which will<br>
&gt;give us some sort of starting point for further discussion. I'm not trying<br>
&gt;to suggest that MW is fully object orientated but code can reside on<br>
objects<br>
&gt;such as colours, turtles, buttons. This gives students an introduction to<br>
&gt;elementary oops concepts and for young kids I can't see the point in going<br>
&gt;beyond that. MW and logo has local variables which would be the main thing,<br>
&gt;wouldn't it? My main impression from doing a little bit of java oops<br>
earlier<br>
&gt;this year is that everything is 10 times harder than in using logo.<br>
&gt;<br>
&gt;&lt;start of paste from MW help&gt;<br>
&gt;turtlesown word<br>
&gt;<br>
&gt;Assigns a variable to all the turtles in the current project. This variable<br>
&gt;can then be set to a specific value for each turtle. This command also<br>
&gt;creates a new primitive made of the word set followed by the name of the<br>
&gt;variable (e.g., turtlesown &quot;speed creates a setspeed command as in t1,<br>
&gt;setspeed 12).<br>
&gt;There are two ways to get the value of a given turtle variable: you can<br>
talk<br>
&gt;to a turtle and use the variable name to report the value (e.g., t1, show<br>
&gt;speed displays 12 in this example) or you can use the turtle name followed<br>
&gt;by 's (e.g., show t1's &quot;speed displays 12).<br>
&gt;<br>
&gt;Use remove to remove a turtle variable. This removes the named variable for<br>
&gt;all the turtles in the project.<br>
&gt;After a turtlesown instruction, the value of the variable is set to the<br>
&gt;empty list (see the first three lines in the example below).<br>
&gt;Example:<br>
&gt;<br>
&gt;turtlesown &quot;speed<br>
&gt;t1, show speed<br>
&gt; (empty list)<br>
&gt;t1, setspeed 10<br>
&gt;t2, setspeed 20<br>
&gt;t3, setspeed 5<br>
&gt;t1, show speed<br>
&gt;10<br>
&gt;show t2's &quot;speed<br>
&gt;20<br>
&gt;everyone [fd speed]<br>
&gt;everyone [forever [fd speed]]<br>
&gt;<br>
&gt;Choose Stop All from the Edit menu.<br>
&gt;<br>
&gt;remove &quot;speed<br>
&gt;&lt;end of paste from MW help&gt;<br>
&gt;<br>
<br>
To me, and many others, the essence of the idea of an object is that it joins local data
and behavior. You ask a object to move and whether it walks, swims, or flies depends upon
the kind of object it is and what &quot;move&quot; methods have been associated with it.
&quot;turtlesown&quot; does give objects some local data (but it is odd that every object
in the system has the same set of local variables). But behavior is critical. (I don't
happen to think inheritance is critical, though it is often quite nice.)<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Bill Kerr:</font></p>

<p><font face="Comic Sans MS">&gt;By the way, is there a MicroWorlds manual on the web
somewhere?<br>
<br>
I think you can download a demo copy of MW, with manual, from <a HREF="http://www.microworlds.com/">www.microworlds.com</a><br>
<br>
&gt;To me, and many others, the essence of the idea of an object is that it<br>
&gt;joins local data and behavior. You ask a object to move and whether it<br>
&gt;walks, swims, or flies depends upon the kind of object it is and what<br>
&quot;move&quot;<br>
&gt;methods have been associated with it. &quot;turtlesown&quot; does give objects some<br>
&gt;local data (but it is odd that every object in the system has the same set<br>
&gt;of local variables). But behavior is critical. (I don't happen to think<br>
&gt;inheritance is critical, though it is often quite nice.)<br>
<br>
I sort of understand what you are getting at. From my Java course I recall that this is
called polymorphism. I'll have to wait until I have some more time for a closer look at
ToonTalk to try to evaluate your comments on both data synchronization and aspects<br>
of OOPs that ought to be incorporated into kids software. Thanks for the prompt responses
to my queries.</font></p>

<p><font face="Comic Sans MS">-- Bill Kerr</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Wen Su:</font></p>

<p><font face="Comic Sans MS">I think that, if my understanding is correct, there is a
major difference between MW and TT here. Suppose in the code below, both subprocesses
(called Circle and Square) that are launched try to modify a variable owned by the current
process (called Parent), in MW, there is no directly built-in mechanism that allows the
Parent process to tell which launched process<br>
modifies the variable first, for example. Of course, this can be done by users by other
means. The same issue arised in low-level hardware driver code, or when both the interrupt
handler code (the code that is triggered to be executed by a hardware interrupt event) and
the main line code try to modify the same variable. In TT, the data change requests are
sent from<br>
Circle and Square to Parent and the requests are placed in a queue, and the Parent process
can tell which data modification request comes in first by means of its built-in message
passing method(bird).<br>
<br>
This above comment (if correct), does not imply that MW is inferior as far as its
education value is concerned, IMHO. Maybe MW developers happen to believe this feature is
not that important for children students. Some people (Ken Kahn?) may believe this is very
very important ( I think that is the reason why he talked about the &quot;global
variable&quot; accessing issue.); some may not.<br>
<br>
Regards,<br>
Wen</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Wen provided a good example in MicroWorlds of my point about
the dangers of concurrency in languages with shared state (the variable owned by the
Parent process in his posting). Thanks.<br>
<br>
His question is about how important this issue is. It would not surprise me if many
readers of this news group have taught MicroWorlds for years and never seen a kid run
across it. Why should we care? One reason is the principle that we shouldn't give kids
programming tools that us adults wouldn't use. nother reason is that kids that do get
ambitious and may start to explore what kinds of parallel programming they can do in
MicroWorlds will run up across these problems. These problems are very hard for
professional programmers to detect, track down, and fix. And even worse is that
MicroWorlds doesn't give its users the tools to deal with these problems (locks or
critical regions, for example).<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt; And even worse<br>
&gt;is that MicroWorlds doesn't give its users the tools to deal with these<br>
&gt;problems (locks or critical regions, for example).<br>
<br>
I don't know what MW does, but StarLogo tries to guarantee correct results without making
the user aware of synchronization issues, by, for example, always guaranteeing that in an
IF, the test and the first action in the conditional instruction sequence are done
atomically.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message
&lt;73pgqn$h6$1@agate.berkeley.edu&gt;...</font></p>

<p><font face="Comic Sans MS">&gt;I don't know what MW does, but StarLogo tries to
guarantee correct</font></p>

<p><font face="Comic Sans MS">&gt;results without making the user aware of synchronization
issues, by,</font></p>

<p><font face="Comic Sans MS">&gt;for example, always guaranteeing that in an IF, the test
and the first</font></p>

<p><font face="Comic Sans MS">&gt;action in the conditional instruction sequence are done
atomically.</font></p>

<p><font face="Comic Sans MS">That probably works fine in a SIMD language like StarLogo.
But atomicity is dangerous in general, since it can lead to deadlock. Here, if the
conditional test is a procedure call then that procedure may in turn access something that
has been locked by this hidden atomicity rule. And then progress stops.</font></p>

<p><font face="Comic Sans MS">Best,</font></p>

<p><font face="Comic Sans MS">-ken kahn (www.toontalk.com)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Tom Woods:</font></p>

<p><font face="Comic Sans MS">Hello, </font></p>

<p><font face="Comic Sans MS">To me, textual programming enables students to express their
thoughts in ways similar to spoken language. Reading, writing, speaking and listening are
necessarily serial. This is not a bad thing. </font></p>

<p><font face="Comic Sans MS">Although I'm not familiar with ToonTalk, I can imagine
visual programming as being akin to other creative visual processes. In the visual arts
the presence of a language is undeniable. With it, artists can express rich parallel
thoughts through images. Neither is this a bad thing. </font></p>

<p><font face="Comic Sans MS">I worry about any implication that one form is inferior to
another which is the message I got when it was said that Logo is &quot;old
technology.&quot; Both forms of expression are important. One is not inferior to another
-- just different. </font></p>

<p><font face="Comic Sans MS">For those of you who may remember my much more active
presence on the list a couple years ago, hello again. I finished school and wound up in
jail. Don't worry, they let me out at the end of the day. I have the wonderfully creative
task of starting a school where nothing existed before. One thing I hope to do soon is
have my some of my students build computers out of salvaged components and get into
programming. Most of the discussions here seem to involve children. Does anyone have any
experience using Logo with adult students? </font></p>

<p><font face="Comic Sans MS">Regards, </font></p>

<p><font face="Comic Sans MS">Tom Woods </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Tom &amp; Adele Woods wrote </font></p>

<p><font face="Comic Sans MS">&gt;To me, textual programming enables students to express
their thoughts in <br>
&gt;ways similar to spoken language. Reading, writing, speaking and listening <br>
&gt;are necessarily serial. This is not a bad thing. <br>
&gt; <br>
&gt;Although I'm not familiar with ToonTalk, I can imagine visual programming as <br>
&gt;being akin to other creative visual processes. In the visual arts the <br>
&gt;presence of a language is undeniable. With it, artists can express rich <br>
&gt;parallel thoughts through images. Neither is this a bad thing. <br>
&gt; <br>
&gt;I worry about any implication that one form is inferior to another which is <br>
&gt;the message I got when it was said that Logo is &quot;old technology.&quot; Both forms
<br>
&gt;of expression are important. One is not inferior to another -- just different. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">I agree, text is good. But as I wrote in another branch of
this thread regarding whether some programming paradigms are superior to others -- there
is a need to prioritize here. If a teacher is going to teach just one language in a course
should it be a visual or textual one? If a parent is buying a programming language for
their children, which language is the best first language? In an ideal world I would love
to see children learn both kinds of languages. (And also both sequential procedural
languages and concurrent object-oriented ones.) </font></p>

<p><font face="Comic Sans MS">Maybe I should rephrase the question of Logo's obsolescence
as &quot;Is Logo still the best as the first programming language children learn?&quot; I
don't believe so. I think visual/animated languages are more appealing to children and
easier to learn. I think concurrent object-oriented languages provide a more natural and
more powerful thinking tool than sequential procedural languages. </font></p>

<p><font face="Comic Sans MS">If one agrees with me, then the next question is whether
Logo is the best second language to learn. I feel less strongly about this issue but
wonder whether a child who has mastered ToonTalk might not be ready for Java or Scheme
instead. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes: <br>
&gt; I think visual/animated languages are more appealing to children <br>
&gt;and easier to learn. </font></p>

<p><font face="Comic Sans MS">IMHO the best solution to this problem is a hybrid system,
in which things that are easily expressed graphically can be, but also, anything can be
expressed textually.&nbsp; Mike Eisenberg's SchemePaint is still the best example of what
I mean.&nbsp; There are the standard paint program point-and-click tools, but you can also
write Scheme programs, and in fact you can make new point-and-click tools by implementing
them as Scheme programs. </font></p>

<p><font face="Comic Sans MS">Microworlds is a decent attempt by the Logo community to
build something along these lines, although it's far from perfect.&nbsp; (I am measuring
perfection right now only on the issue of the interchangeability of text and graphics
interfaces.) </font></p>

<p><font face="Comic Sans MS">Maybe ToonTalk is, too, since you say that it produces Java
code.&nbsp; If the Java code isn't too convoluted (I haven't yet had a chance to play with
it -- I'll try to do that soon!) and if you can use Java code to create new capabilities
in the GUI, then I'll be pleased. </font></p>

<p><font face="Comic Sans MS">Btw, to say that concurrency is &quot;natural&quot; for
people raises a lot of questions for me.&nbsp; Indeed, I believe that if you're simulating
a world of independent actors, it feels natural to program them separately. But my CS
students certainly don't find natural the synchronization problems that arise if those
actors want to share state! </font></p>

<p><font face="Comic Sans MS">(And finally, you and others have mentioned that different
people have different learning styles; part of mine happens to be that I don't really want
to make animations, and I'm more likely to want to know how many combinations a Simplex
lock has.&nbsp; I guess I'm weird.&nbsp; :-)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote <br>
&gt;IMHO the best solution to this problem is a hybrid system, in which <br>
&gt;things that are easily expressed graphically can be, but also, anything <br>
&gt;can be expressed textually. </font></p>

<p><font face="Comic Sans MS">I think this is a great research topic. But I worry about
the compromises that would be needed to make this work well for a general-purpose
programming language. And I also am uncertain about whether hybrids adds some kind of
cognitive complexity. On the other hand, it is always a good thing to be able to see or
understand the same thing in multiple ways. </font></p>

<p><font face="Comic Sans MS">&gt; <br>
&gt;Maybe ToonTalk is, too, since you say that it produces Java code.&nbsp; If <br>
&gt;the Java code isn't too convoluted (I haven't yet had a chance to play <br>
&gt;with it -- I'll try to do that soon!) and if you can use Java code to <br>
&gt;create new capabilities in the GUI, then I'll be pleased. <br>
&gt; </font></p>

<p><font face="Comic Sans MS">The Java code is readable but not the kind of code one would
write from scratch. Making it possible to change the Java code and have that reflected
back into ToonTalk is a very difficult problem. </font></p>

<p><font face="Comic Sans MS">&gt;Btw, to say that concurrency is &quot;natural&quot; for
people raises a lot of <br>
&gt;questions for me.&nbsp; Indeed, I believe that if you're simulating a world <br>
&gt;of independent actors, it feels natural to program them separately. <br>
&gt;But my CS students certainly don't find natural the synchronization <br>
&gt;problems that arise if those actors want to share state! <br>
&gt; </font></p>

<p><font face="Comic Sans MS">I agree if the sharing of state is &quot;direct&quot; rather
than via message passing. That's why I keep complaining about global variables as the only
means of communication in MicroWorlds. I'll write a longer essay on this issue soon and
post it here. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes: <br>
&gt;The Java code is readable but not the kind of code one would write from <br>
&gt;scratch. Making it possible to change the Java code and have that reflected <br>
&gt;back into ToonTalk is a very difficult problem. </font></p>

<p><font face="Comic Sans MS">I'm not asking for that.&nbsp; I'm asking to be able to
write, in Java, a new gizmo, let's say a different kind of magic wand, or a new menu item,
or whatever, and integrate that into the TT world.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Bob Gorman:</font></p>

<p><font face="Comic Sans MS">At 11/18/98 05:24 AM -0800, Brian Harvey wrote: <br>
&gt;I guess I think text gets a bum rap these days.&nbsp; We used to have nothing</font></p>

<p><font face="Comic Sans MS">&gt;but text, and everyone has overreacted.&nbsp; Text is
still a really expressive medium!&nbsp; </font></p>

<p><font face="Comic Sans MS">Even for emotions, let alone computer programs. I
whole-heartily agree. We have a left brain, which enjoys text, and a right brain which
enjoys pictures. While so many competitive arguments try to prove that their favorite side
is &quot;better&quot;, I would simply reply, there is nothing with using BOTH! Indeed, I
sometimes group people into 4 categories: Right brain dominant, Left brain dominant, Both
brain dominant, and of course, neither! </font></p>

<p><font face="Comic Sans MS">Bob </font></p>

<p><font face="Comic Sans MS">&quot;To get <font COLOR="#ff0000">NEW </font><font COLOR="#0000ff">Answers, you must ask </font><font COLOR="#ff0000">NEW </font><font COLOR="#0000ff">Questions!&quot; - </font><font COLOR="#ff0000">Bob </font></font><font COLOR="#0000ff" face="Comic Sans MS">Gorman</font><font COLOR="#0000ff"></p>
</font>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Dale R. Reed: </font></p>

<p><font face="Comic Sans MS">Bob Gorman wrote: <br>
&gt;We have a left brain, which enjoys text, and a right brain which enjoys pictures. </font></p>

<p><font face="Comic Sans MS">I enjoy text(poetry, novels) that create pictures in the
mind.&nbsp; For instance I like to read Victor Hugo. </font></p>

<p><font face="Comic Sans MS">With Logo I can use text to create pictures that are not
exactly as I thought they would be. </font></p>

<p><font face="Comic Sans MS">I can suprise myself.&nbsp;&nbsp; I like
that.&nbsp;&nbsp;&nbsp;&nbsp; </font></p>

<p><font face="Comic Sans MS">Dale --- $ <a HREF="mailto:dale-reed@worldnet.att.net">dale-reed@worldnet.att.net</a>&nbsp;
Seattle, Washington U.S.A. $ </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; Bob Gorman wrote &nbsp;&nbsp;&nbsp; We
have a left brain, which enjoys text, and a right brain which enjoys pictures. While so
many competitive arguments try to prove that their favorite side is &quot;better&quot;, I
would simply reply, there is nothing with using BOTH! </font></p>

<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; Some people are called &quot;visual
thinkers&quot; because they seem to be good at solving visual problems and they report
using visual imagery when thinking. For these people, textual programming languages are
difficult. Visual thinkers would probably both prefer visual programming languages and
also be more effective in using them than textual languages. Other people seem to prefer
text and symbols. Maybe ToonTalk isn't so appropriate for them. A hybrid textual-visual
language might satisfy both kinds of thinkers, but it might not. Compromises are needed to
make a good hybrid. And hybrids tend to be more complex and much harder to engineer.
&nbsp;&nbsp;&nbsp; I suspect that kids, particularly younger ones, are more visual and
less textual/symbolic in their thinking. I know that these categories are crude and overly
simplistic but I think they are useful ways of thinking about these issues.
&nbsp;&nbsp;&nbsp; Does anyone know of psychological research on these questions?
&nbsp;&nbsp;&nbsp;</font></p>

<p><font face="Comic Sans MS">Best, &nbsp;&nbsp;&nbsp; </font></p>

<p><font face="Comic Sans MS">ken kahn </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes: <br>
&gt; Compromises are needed to make a good hybrid. </font></p>

<p><font face="Comic Sans MS">No, no!&nbsp; Compromises make a bad hybrid.&nbsp; Syntheses
are needed for a good one. (I learned this in Marxism class.)&nbsp; Compromise would be
like those old &quot;macro&quot; systems for the Mac that recorded mouse clicks in pixel
coordinates. </font></p>

<p><font face="Comic Sans MS">So for example, take that exchange-two-values thing you did
in TT the other night.&nbsp; Does the corresponding Java code look like pixels, or does it
look like the way you'd program an exchange directly in Java?&nbsp; (Well, I guess it
can't, exactly, but I'd settle for exch(a, b) where exch is a procedure you supply that
finds a nice vacant part of the screen.)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote<br>
&gt;No, no!&nbsp; Compromises make a bad hybrid.&nbsp; Syntheses are needed for a good<br>
one.<br>
&gt;(I learned this in Marxism class.)&nbsp; Compromise would be like those old<br>
&quot;macro&quot;<br>
&gt;systems for the Mac that recorded mouse clicks in pixel coordinates.<br>
&gt;<br>
I'll agree with that (despite seldom agreeing with Marxism).</font></p>

<p><font face="Comic Sans MS">&gt;So for example, take that exchange-two-values thing you
did in TT the other<br>
&gt;night.&nbsp; Does the corresponding Java code look like pixels, or does it look<br>
&gt;like the way you'd program an exchange directly in Java?&nbsp; (Well, I guess it<br>
&gt;can't, exactly, but I'd settle for exch(a, b) where exch is a procedure you<br>
&gt;supply that finds a nice vacant part of the screen.)</font></p>

<p><font face="Comic Sans MS">Somewhere inbetween. Here's the untouched automatically
generated Java program from having trained a robot to swap 2 numbers if they are out of
order. A great project (any grad students out there lurking?) is to build a tool that
transform the following Java code into something more normal. My guess is that a good
partial evaluator could do the job.</font></p>

<p><font face="Comic Sans MS">Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<br>
import ap.toontalk.*;<br>
class Robot_P extends TTRobot {<br>
Robot_P(TTNotebook n) {<br>
&nbsp; notebook = n;<br>
}<br>
public TTObject gets(TTObject given) throws TTException {<br>
&nbsp; if (!wants.matches(given)) return null;<br>
&nbsp; // If given a box that matches the box in his thought bubble (called
&quot;wants&quot;),<br>
&nbsp; // this robot will do the following.<br>
&nbsp; TTObject hand;<br>
&nbsp; TTObject temp1;<br>
&nbsp; // pick up what's in the first hole inside his box<br>
&nbsp; hand = given.pickUp(0);<br>
&nbsp; // drop it<br>
&nbsp; temp1 = hand;<br>
&nbsp; // pick up what's in the third hole inside his box<br>
&nbsp; hand = given.pickUp(2);<br>
&nbsp; // drop it on the first hole inside his box<br>
&nbsp; given.holeGets(0, hand);<br>
&nbsp; // pick up the last thing he made or found<br>
&nbsp; hand = temp1;<br>
&nbsp; // drop it on the third hole inside his box<br>
&nbsp; given.holeGets(2, hand);<br>
&nbsp; return this;&nbsp; // This robot has finished and will see if the box still matches
his thoughts and try again.<br>
}<br>
}<br>
public class Applet_P extends TTApplet {<br>
public static void main(String args[]) {<br>
&nbsp; new TTFrame().begin(new Applet_P());<br>
}<br>
public void initialize() {<br>
&nbsp; TTNotebook notebook = TT.NOTEBOOK;<br>
&nbsp; box = new TTBox(3);<br>
&nbsp; box.setHole(0, new TTInteger(2, '+'));<br>
&nbsp; box.setHole(1, new TTScale('&gt;'));<br>
&nbsp; box.setHole(2, new TTInteger(1, '+'));<br>
&nbsp; // We just made a box with 3 holes. The first hole contains the number 2. The<br>
&nbsp; // second hole contains a scale tipped to the left. The third hole contains<br>
&nbsp; // the number 1.<br>
&nbsp; robot = new Robot_P(notebook);<br>
&nbsp; TTBox wants1 = new TTBox(3);<br>
&nbsp; // This robot will only accept a box with 3 holes. The first hole contains<br>
&nbsp; // any number. The second hole contains a scale tipped to the left. The third<br>
&nbsp; // hole contains any number.<br>
&nbsp; wants1.setHole(0, TT.BLANK_NUMBER);<br>
&nbsp; wants1.setHole(1, new TTScale('&gt;'));<br>
&nbsp; wants1.setHole(2, TT.BLANK_NUMBER);<br>
&nbsp; robot.setWants(wants1);<br>
&nbsp; team = new TTTeam(box, robot);<br>
&nbsp; setStartingTeam(team);<br>
&nbsp; displayThis(box);<br>
}<br>
}<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;&nbsp; hand = given.pickUp(0);<br>
&gt;&nbsp; temp1 = hand;<br>
&gt;&nbsp; hand = given.pickUp(2);<br>
&gt;&nbsp; given.holeGets(0, hand);<br>
&gt;&nbsp; hand = temp1;<br>
&gt;&nbsp; given.holeGets(2, hand);<br>
<br>
Decent!&nbsp; I'm impressed.&nbsp; Would it work without &quot;hand&quot;?&nbsp; I mean,
if we changed the Java code to<br>
<br>
&nbsp; temp1 = given.pickUp(0);<br>
&nbsp; given.holeGets(0, given.pickUp(2));<br>
&nbsp; given.holeGets(2, temp1);<br>
<br>
would it animate in some decent way?&nbsp; (Imho that would include just having it all
happen in a flash -- as long as it doesn't blow up or leave confetti on the screen or
something.)</font></p>

<p><font face="Comic Sans MS">If this sort of thing works, it opens the door for the kind
of text-mode programmability that I (following Eisenberg) want. </font></p>

<p><font face="Comic Sans MS">[Too bad it's Java with all that fluff about Public blah
blah... :-)</font></p>

<p><font face="Comic Sans MS">If only it were Logo, this would be perfect.]</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote<br>
&gt;Decent!&nbsp; I'm impressed.&nbsp; Would it work without &quot;hand&quot;?&nbsp; I
mean, if<br>
&gt;we changed the Java code to<br>
&gt;<br>
&gt;&nbsp; temp1 = given.pickUp(0);<br>
&gt;&nbsp; given.holeGets(0, given.pickUp(2));<br>
&gt;&nbsp; given.holeGets(2, temp1);<br>
&gt;<br>
&gt;would it animate in some decent way?&nbsp; (Imho that would include just<br>
&gt;having it all happen in a flash -- as long as it doesn't blow up or<br>
&gt;leave confetti on the screen or something.)<br>
&gt;<br>
That should work. And a little &quot;peephole optimizer&quot; could probably automatically
generate it. </font></p>

<p><font face="Comic Sans MS">But I should clarify that the Java applet doesn't show
ToonTalk programming environment graphics. In this case you don't see the hand when
running as an Applet. If, on the other hand, you build a graphical application inside of
ToonTalk (e.g. the Ping Pong game example), then those graphics will be transferred to
Java.</font></p>

<p><font face="Comic Sans MS">Best,</font></p>

<p><font face="Comic Sans MS">-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Tom Woods:</font></p>

<p><font face="Comic Sans MS">Ken Kahn wrote: </font></p>

<p><font face="Comic Sans MS">&gt;I agree, text is good. But as I wrote in another branch
of this thread <br>
&gt;regarding whether some programming paradigms are superior to others -- there <br>
&gt;is a need to prioritize here. If a teacher is going to teach just one <br>
&gt;language in a course should it be a visual or textual one? </font></p>

<p><font face="Comic Sans MS">Part of the key to this issue is the definition of
&quot;superior,&quot; and that depends on your priorities. </font></p>

<p><font face="Comic Sans MS">My priorities: 1. Give students rich and varied
opportunities to express their thoughts verbally, visually, auditorially, and
kinesthetically. 2. Give students opportunities to think about how they think. </font></p>

<p><font face="Comic Sans MS">Because programming languages are among the things that
offer possibilities in these two areas, I'm interested in exploring ways they can be
included in students' learning. If I had to ask a question like you did above, I would
ask, If a teacher is going to teach just one language, what will best meet the needs of
the students?&quot; I like the answer Brian Harvey stated: </font></p>

<p><font face="Comic Sans MS"><br>
&gt;IMHO the best solution to this problem is a hybrid system, in which <br>
&gt;things that are easily expressed graphically can be, but also, anything <br>
&gt;can be expressed textually. </font></p>

<p><font face="Comic Sans MS">Tom Woods </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Tom &amp; Adele Woods wrote in message &lt;<a HREF="mailto:1.5.4.32.19981123051027.006dbdd4@moose.ncia.net">1.5.4.32.19981123051027.006dbdd4@moose.ncia.net</a>&gt;...
<br>
&gt; <br>
&gt;My priorities: <br>
&gt;1. Give students rich and varied opportunities to express their thoughts <br>
&gt;verbally, visually, auditorially, and kinesthetically. </font></p>

<p><font face="Comic Sans MS">I find this a very exciting idea to pursue. In this
discussion I have been emphasizing ToonTalk's visual/animated nature. These other sensory
modalities are important and I have made steps in that direction. ToonTalk makes heavy use
of sound effects. More interestingly, it uses both canned speech and a text-to-speech
engine. If you have a force-feedback joystick (these cost about $100 these days), then
when you use ToonTalk you feel the vibrations of the helicopter engine, or the wall when
you walk into it, or the weight of something in your hand. Within the next 9 months I plan
to integrate speech input into ToonTalk. </font></p>

<p><font face="Comic Sans MS">Maybe it doesn't need to be said to this audience, but these
modalities should be available for kids to use in their own creations. For example,
ToonTalk not only uses force-feedback but gives kids the option of including force effects
in their own programs. Ditto for sound effects and text-to-speech. And speech input when
it is done. </font></p>

<p><font face="Comic Sans MS">I don't claim to have the answers for how to best use and
integrate these varied modalities. There is room for basic research, as well as a variety
of engineering efforts, to explore these issues. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)
</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Tom Woods:</font></p>

<p><font face="Comic Sans MS">Wen Su wrote:<br>
<br>
&gt;To express their thoughts verbally using computers is still not<br>
&gt;much different than using pencils and papers, as our previous<br>
&gt;generation did.<br>
<br>
Very true. The pencil is a &quot;letter quality printer.&quot; Nor is visual expression on
a computer vastly different from painting or drawing. I wouldn't want to forsake the
pencil and brush for a computer. Students would benefit from exposure to all the tools, I
feel. </font></p>

<p><font face="Comic Sans MS">&gt;I hesitate to be a &quot;nay-sayer&quot; here. But
although it is very<br>
&gt;good to give students a multimedia construction tool so that<br>
&gt;they can express their thoughts in these new multimedia tools,<br>
&gt;most tools today are still not easy enough to use for youngsters<br>
&gt;(or even for adults.) <br>
<br>
Again true... for the pencil and brush as well. Just ask a student if writing is easy.
Just try to paint a picture and get it just the way you want. </font></p>

<p><font face="Comic Sans MS"><br>
Tom Woods</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Tom Woods:</font></p>

<p><font face="Comic Sans MS">Ken Kahn wrote:<br>
&gt; In this discussion I have been<br>
&gt;emphasizing ToonTalk's visual/animated nature. These other sensory<br>
&gt;modalities are important...<br>
<br>
NOW you're talkin' When you get the speech working, will you have equivalent text too?
That would be extremely beneficial for emerging and early readers who often start by
reading words they have written or spoken themselves. You might be on to something big.<br>
<br>
Tom Woods</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Bill Kerr:</font></p>

<p><font face="Comic Sans MS">Ken Kahn wrote:<br>
I agree most people like what they already know. This might mean that teachers won't give
ToonTalk the chance it deserves. </font></p>

<p><font face="Comic Sans MS">and also in another post replying to Tom Woods: </font></p>

<p><font face="Comic Sans MS">Maybe I should rephrase the question of Logo's obsolescence
as &quot;Is Logo still the best as the first programming language children learn?&quot; I
don't believe so. I think visual/animated languages are more appealing to children and
easier to learn. I think concurrent object-oriented languages provide a more natural and
more powerful thinking tool than sequential procedural languages. </font></p>

<p><font face="Comic Sans MS">--------------------------------- </font></p>

<p><font face="Comic Sans MS">I like the way you have rephrased your challenge to Logo,
which makes it more likely I'll get around to looking at ToonTalk, when I get time from
writing reports</font></p>

<p><font face="Comic Sans MS">With regard to teachers giving TT the chance it deserves:
this made me think of something in a book on &quot;Learning in Science&quot; by Osborne
&amp; Freyberg (it's a book about Childrens Science), which I just looked up to refresh my
memory, I quote:</font></p>

<p><font face="Comic Sans MS">&quot;Ideas lose status as they become less intelligible,
plausible and fruitful. Conversely, new ideas increase in status as they become more
intelligible, more plausible and more fruitful.&quot; (48) [they write more about exactly
what they mean by these terms] </font></p>

<p><font face="Comic Sans MS">Although I have invested a lot of time in MicroWorlds and it
rates well on these 3 criteria I think I should have a hard look at your alternative. It
would be foolish to think that Logo/MicroWorlds/next evolution will *always* be the&nbsp;
best first language for kids. From other perspectives I see other problems, however: </font></p>

<p><font face="Comic Sans MS">my perspective: the trial you are organising is a comparison
with Superlogo not MicroWorlds (I don't know much about Superlogo) </font></p>

<p><font face="Comic Sans MS">your perspective (mine too): the actual market for kids
programming languages seems to be shrinking, as more sophisticated pre-packed simulations,
like sim-life etc. come on stream. </font></p>

<p><font face="Comic Sans MS">-- Bill Kerr </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">Ken Kahn then posted <a HREF="concur.htm">an essay</a> on
&quot;Logo with parallel processes vs. ToonTalk&quot;.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;In the recent discussion about Logo and ToonTalk, one of the issues was<br>
&gt;about concurrency. I promised a longer response to the question about<br>
&gt;whether the parallelism supported by MicroWorlds is as good as what ToonTalk<br>
&gt;offers. Here's my 7 paragraph long answer:<br>
<br>
This is really helpful!&nbsp; Now I think I can articulate where we differ.<br>
<br>
&gt;The lack of subroutines in ToonTalk makes it much more feasible to have much<br>
&gt;larger number of processes than conventional programming languages. The<br>
&gt;reason for this is that everyone implements subroutine calls using a data<br>
&gt;structure called a stack. Stacks are a very effective way of implementing<br>
&gt;procedural calls, including recursive calls. The problem is that each<br>
&gt;process needs its own stack. This makes processes somewhat costly. I've<br>
&gt;tested ToonTalk with tens of thousands of houses (i.e. processes). In<br>
&gt;contrast, when I used Java, it stopped working when I had just a couple<br>
&gt;hundred processes.<br>
<br>
I don't understand this.&nbsp; If the processes were doing embedded recursion, so that you
really need to keep all the state of all the procedure calls around, then I don't
understand how you're avoiding it.&nbsp; If your complaint is that the Java stack grows on
tail calls, then the problem isn't with subroutines, but with inferior language
implementations. Use Berkeley Logo instead!&nbsp; It does correct tail call elimination.<br>
<br>
&gt;Conventional languages have shared state. The same variables, data<br>
&gt;structures, and objects can be accessed from different processes (processes<br>
&gt;that share data are often called threads). Sharing state is necessary in<br>
&gt;these languages in order for threads to work together.<br>
<br>
Ah, now I see why you keep (incorrectly) saying &quot;global variables&quot; when
describing the alleged limitations of Logo.&nbsp; Your concern is not with the scope of
the variables but with the sharing across processes. But (and this is the main point I
want to make here) there is another way to harness concurrency without running into
synchronization errors: functional programming!&nbsp; Race conditions are possible only if
the various threads are reassigning values to variables.&nbsp; But there's no need ever to
do that.&nbsp; (In Logo terms, you never need to use MAKE.) When you lump functional
programming in with sequential programming, I think you're not really doing justice to the
power of procedure calling as a control mechanism. Some computations really lend
themselves to the imperative model of programming you describe.&nbsp; But what about the
classic Logo example of English sentence generation?&nbsp; I think this is best described
as a composition of functions.&nbsp; And even if the arguments to functions are computed
concurrently, there is no synchronization problem. Now, in a way, you DO provide for
function calling, with the birds and stuff.&nbsp; But I think that, because you deprecate
the idea, your metaphor makes function calling much more complicated than it should
be.&nbsp; I still don't see why every function call should HAVE to be a separate process
-- maybe because I don't understand what you're saying about stack space.&nbsp; Are you
saying that separate processes ensure no mutation of shared variables?&nbsp; Couldn't you
achieve the same thing by not allowing robots (procedures, I take it) to mutate things
outside of themselves?</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote<br>
&gt;I don't understand this.&nbsp; If the processes were doing embedded recursion,<br>
&gt;so that you really need to keep all the state of all the procedure calls<br>
&gt;around, then I don't understand how you're avoiding it.&nbsp; If your<br>
&gt;complaint is that the Java stack grows on tail calls, then the problem<br>
&gt;isn't with subroutines, but with inferior language implementations.<br>
&gt;Use Berkeley Logo instead!&nbsp; It does correct tail call elimination.<br>
&gt;<br>
<br>
I agree that procedural languages should do tail recursion optimization. But I was trying
to make another point. ToonTalk could be implemented as a un-ordered collection of process
records. A process record is like a stack frame - it contains a pointer to the code
(robots in ToonTalk) and an argument vector (a box in ToonTalk). To be fairer to
conventional languages, while ToonTalk has very cheap processes, ordinary procedure calls
are more costly since they use the heap rather than a stack. But the fact that stacks are
not used is why process spawning, suspension, and termination are very cheap operations in
ToonTalk. <br>
&gt;<br>
&gt;But (and this is the main point I want to make here) there is another<br>
&gt;way to harness concurrency without running into synchronization errors:<br>
&gt;functional programming!&nbsp; Race conditions are possible only if the<br>
&gt;various threads are reassigning values to variables.&nbsp; But there's no<br>
&gt;need ever to do that.&nbsp; (In Logo terms, you never need to use MAKE.)<br>
&gt;When you lump functional programming in with sequential programming,<br>
&gt;I think you're not really doing justice to the power of procedure<br>
&gt;calling as a control mechanism.<br>
&gt;<br>
&gt;Some computations really lend themselves to the imperative model of<br>
&gt;programming you describe.&nbsp; But what about the classic Logo example<br>
&gt;of English sentence generation?&nbsp; I think this is best described as<br>
&gt;a composition of functions.&nbsp; And even if the arguments to functions<br>
&gt;are computed concurrently, there is no synchronization problem.<br>
&gt;<br>
<br>
I agree that in programs without side-effects as in functional programming all my
objections and concerns about synchronization disappear. And I agree some nice programs
can be written in a pure functional style, e.g. your sentence generator. But (and this is
my main point here) there are too many programs that cannot be written as pure functions.
The bank account example I gave earlier is one. Or a score keeper in a game. Or most
simulations, animations, games, etc. Even programs that do I/O are hard to fit into the
pure functional framework.<br>
<br>
&gt;Now, in a way, you DO provide for function calling, with the birds<br>
&gt;and stuff.&nbsp; But I think that, because you deprecate the idea, your<br>
&gt;metaphor makes function calling much more complicated than it<br>
&gt;should be.&nbsp; I still don't see why every function call should HAVE to<br>
&gt;be a separate process -- maybe because I don't understand what<br>
&gt;you're saying about stack space.&nbsp; Are you saying that separate processes<br>
&gt;ensure no mutation of shared variables?&nbsp; Couldn't you achieve the same<br>
&gt;thing by not allowing robots (procedures, I take it) to mutate things<br>
&gt;outside of themselves?<br>
<br>
I would rather say I provide a programming technique or pattern of ToonTalk usage that
corresponds exactly to function calling. And I admit it is a bit more complicated when all
you want to do is function calling. But I claim you want something more general than
function calling. Suppose you want to return 2 items? In ToonTalk you just put 2 birds in
the box and as the values are computed they are given to the birds and their corresponding
nests get filled. Suppose you don't want a single value but a stream of answers. Maybe
even an infinite stream (e.g. the Sieve of Erathosthenes prime number generator). Suppose
you want to create a network of cooperating agents. And why should one try to force
message passing between objects to fit into the framework of function calling? </font></p>

<p><font face="Comic Sans MS">We may be losing all but the serious programmers and
computer scientists on this list, but I think this is a good thread. I'm learning how to
be clearer about what I'm doing. </font></p>

<p><font face="Comic Sans MS">Best, </font></p>

<p><font face="Comic Sans MS">-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)
</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt; But the fact that stacks<br>
&gt;are not used is why process spawning, suspension, and termination are very<br>
&gt;cheap operations in ToonTalk.<br>
<br>
I still don't get it, I'm afraid; why is a frame on the stack more expensive than a frame
on the heap?&nbsp; Is this some PC-specific thing I don't know about?<br>
<br>
&gt;I would rather say I provide a programming technique or pattern of ToonTalk<br>
&gt;usage that corresponds exactly to function calling. And I admit it is a bit<br>
&gt;more complicated when all you want to do is function calling. But I claim<br>
&gt;you want something more general than function calling. Suppose you want to<br>
&gt;return 2 items?<br>
<br>
Interesting -- we are having just that argument right now over on comp.lang.scheme; the
implementor types have put in multiple return values for efficiency reasons, and the
lambda fans hate it.<br>
<br>
But I don't want to make you do everything functionally.&nbsp; What I want is a language
that doesn't impose one paradigm on me, but allows me to choose what's best for the
problem at hand.&nbsp; So, it's not that I want you to leave anything out; I want you to
make function composition easier, also!</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote<br>
&gt;I still don't get it, I'm afraid; why is a frame on the stack more<br>
&gt;expensive than a frame on the heap? Is this some PC-specific thing<br>
&gt;I don't know about?<br>
&gt;<br>
<br>
I'm sorry, I'm not being clear. Let me start again.<br>
<br>
In procedural language implementations, when a procedure is called (non-tail recursively)
a frame or record is pushed onto a stack. Each thread or process needs its own stack. When
a thread suspends all the memory devoted to the stack is tied up until the process resumes
and the procedure calls unwind.<br>
<br>
In ToonTalk and related languages, the only memory that a process needs is for 2 pointers:
to the program (robots) and to the data (box). There is no stack. There is no other state.
That is the point I was trying to make.<br>
<br>
Because of this 100,000 processes in ToonTalk is feasible. (The default city size only
holds 400 houses but the largest size holds about a 250,000 houses.) What is a reasonable
upper limit for the number of processes in Logo?<br>
<br>
Some reader may wonder why this matters for kids? Massive parallelism has been shown to
useful when kids use StarLogo. In ToonTalk we can have parallelism to the same scale as
StarLogo but MIMD (multiple instructions multiple data), not the much more limitted SIMD
(single instruction multiple data) of StarLogo. ToonTalk enables one to put a few
processes behind each pixel on the screen if you want.<br>
<br>
&gt;<br>
&gt;But I don't want to make you do everything functionally. What I want<br>
&gt;is a language that doesn't impose one paradigm on me, but allows me<br>
&gt;to choose what's best for the problem at hand. So, it's not that I<br>
&gt;want you to leave anything out; I want you to make function composition<br>
&gt;easier, also!<br>
<br>
But your argument about why concurrency is harmless in functional languages doesn't
generalize to the multiple paradigm language you are suggesting. If you don't do
everything functionally then concurrency is dangerous and complex. Unless you do things
the way ToonTalk does.<br>
<br>
Best,<br>
<br>
-ken kahn<br>
<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;In procedural language implementations, when a procedure is called (non-tail<br>
&gt;recursively) a frame or record is pushed onto a stack. Each thread or<br>
&gt;process needs its own stack. When a thread suspends all the memory devoted<br>
&gt;to the stack is tied up until the process resumes and the procedure calls<br>
&gt;unwind.<br>
&gt;<br>
&gt;In ToonTalk and related languages, the only memory that a process needs is<br>
&gt;for 2 pointers: to the program (robots) and to the data (box). There is no<br>
&gt;stack. There is no other state. That is the point I was trying to make.<br>
<br>
I still don't see the point. If you take a computation that is naturally expressed as ONE
PROCESS with 100,000 procedure calls, and instead make it 100,000 processes, each with (in
effect) one procedure call, you haven't saved any storage. If Logo would have needed
100,000 procedure calls, it's because there are 100,000 pieces of saved state needed for
the computation.<br>
Why does it matter whether those 100,000 frames are on one stack or divided among 100,000
processes?<br>
<br>
If you're saying that you can't have 100,000 processes each doing 100,000 procedure calls,
then I agree -- but that's not a fair argument. Logo doesn't do that. No language does
that.<br>
<br>
Maybe I should put it this way: Instead of 100,000 stack frames, you have 100,000 bird
nests. (If you're not using birds, then you are doing something that would be a tail call
in Logo, and it's not going to grow the stack.)<br>
<br>
&gt;But your argument about why concurrency is harmless in functional languages<br>
&gt;doesn't generalize to the multiple paradigm language you are suggesting. If<br>
&gt;you don't do everything functionally then concurrency is dangerous and<br>
&gt;complex. Unless you do things the way ToonTalk does.<br>
<br>
That's why I proposed a compromise: Allow a process to mutate only its own private
variables. So as long as you avoid mutation you can have shared data.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote<br>
&gt;I still don't see the point. If you take a computation that is naturally<br>
&gt;expressed as ONE PROCESS with 100,000 procedure calls, and instead make it<br>
&gt;100,000 processes, each with (in effect) one procedure call, you haven't<br>
&gt;saved any storage. If Logo would have needed 100,000 procedure calls, it's<br>
&gt;because there are 100,000 pieces of saved state needed for the computation.<br>
&gt;Why does it matter whether those 100,000 frames are on one stack or<br>
&gt;divided among 100,000 processes?<br>
&gt;<br>
&gt;If you're saying that you can't have 100,000 processes each doing 100,000<br>
&gt;procedure calls, then I agree -- but that's not a fair argument. Logo<br>
&gt;doesn't do that. No language does that.<br>
&gt;<br>
&gt;Maybe I should put it this way: Instead of 100,000 stack frames, you have<br>
&gt;100,000 bird nests. (If you're not using birds, then you are doing<br>
something<br>
&gt;that would be a tail call in Logo, and it's not going to grow the stack.)<br>
&gt;<br>
<br>
100,000 houses. Bird nests are only needed if a computation in a house needs to receive
data or requests from other houses.<br>
<br>
And yes, languages like ToonTalk can have 100,000 processes each doing procedure calls. I
just tried to fill a ToonTalk city with 160,000 houses (it started getting too slow and
paging too much after 50,000). In every house a robot is working away counting (they
needn't be doing the same thing - I'm just lazy). If you want to try it yourself, change
the city size to 200 (that is 200x200 blocks where each block holds 4 houses). You can
find a remote control for the size of your city in the Options notebook. Then train a
robot to get the robot that repeatedly adds 1 and load him in a truck together with a box
with a 1 in it. If you are patient enough you can then just let that robot start up the
other 159,999 processes but once some of those processes start working that robot won't
get a time slice very often. So train another robot to drop copies of the robot you
trained into a truck. Wait a few minutes and then start flying around the city visiting
houses.<br>
<br>
Why would kids want so many processes? Because I think each object should be a process.
And I believe that kids think so to. The idea of objects that are &quot;dead&quot; unless
they are processing some message from the outside is strange, even if it is the way C++,
Java, Object Logo, etc. work.<br>
<br>
&gt;<br>
&gt;That's why I proposed a compromise: Allow a process to mutate only its<br>
&gt;own private variables. So as long as you avoid mutation you can have<br>
&gt;shared data.<br>
<br>
So are objects private to a process? How do they communicate between processes? Or is it
that the instance variables of the objects are private to the process, but object
references are global?<br>
<br>
Best,<br>
<br>
-ken kahn<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;And yes, languages like ToonTalk can have 100,000 processes each doing<br>
&gt;procedure calls.<br>
<br>
Now I'm really lost. You argued that procedure calling is bad because they require stack
frames, whereas processes are good because they don't. I asked, why does it matter whether
state information is on a stack or in a heap -- either you need the state information, in
which case it doesn't matter where you store it, or you don't need it, in which case it
certainly doesn't matter where you don't store it. You were proposing parallelism as an
alternative to composition of functions. And I still don't see why parallelism requires
less storage than composition of functions.<br>
<br>
&gt;So are objects private to a process? How do they communicate between<br>
&gt;processes? Or is it that the instance variables of the objects are private<br>
&gt;to the process, but object references are global?<br>
<br>
Data that belongs to an object shouldn't be a problem; the object is in charge of that
data, and it ensures the atomicity of requests to use the data, which it can do because it
exports the methods to access the data. It's data not belonging to an object that we have
to worry about.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a HREF="mailto:73ph80$lp$1@agate.berkeley.edu">73ph80$lp$1@agate.berkeley.edu</a>&gt;...<br>
&gt;&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt;
writes:<br>
&gt;&gt;And yes, languages like ToonTalk can have 100,000 processes each doing<br>
&gt;&gt;procedure calls.<br>
&gt;<br>
&gt;Now I'm really lost. You argued that procedure calling is bad because<br>
&gt;they require stack frames, whereas processes are good because they don't.<br>
&gt;I asked, why does it matter whether state information is on a stack or<br>
&gt;in a heap -- either you need the state information, in which case it<br>
&gt;doesn't matter where you store it, or you don't need it, in which case<br>
&gt;it certainly doesn't matter where you don't store it. You were proposing<br>
&gt;parallelism as an alternative to composition of functions. And I still<br>
&gt;don't see why parallelism requires less storage than composition of<br>
&gt;functions.<br>
&gt;<br>
<br>
One reason for your confusion is that I probably shouldn't have used the<br>
word &quot;procedure calls&quot; above. Maybe repeatedly excuting a block of<br>
instructions might have been a better way to say it. They are not each<br>
executing a procedure that in turn calls any other procedures.<br>
<br>
The stack vs. heap issue isn't the main point but let me try to clarify it.<br>
A stack is typically implemented as a block of memory. If the stack grows<br>
too deep, then either a larger block needs to be allocated and the<br>
information needs to be copied over or the another block of memory needs to<br>
be allocated and linked into the original stack. If the heap is used (either<br>
as in ToonTalk or as alternative way of implementing a stack), then there is<br>
nothing corresponding to the unused portion of the block of memory allocated<br>
for a stack. When the number of processes or threads is in the thousands or<br>
hundreds of thousands this can be an important issue. If you expect typical<br>
programs to have tens or hundreds of threads then a stack is a more<br>
efficient data structure than using the heap. My point is that all<br>
sequential languages with threads that I'm aware of are implemented with<br>
stacks. Hence a low limit on the number of processes that are practical.<br>
<br>
On the main point, let's consider a program like this. (Excuse me if I make<br>
any syntax mistakes, it has been a very long time since I've written a Logo<br>
program.)<br>
<br>
to a<br>
b<br>
c<br>
end<br>
<br>
to b<br>
d<br>
e<br>
end<br>
<br>
to d<br>
some code that causes this process to suspend<br>
end<br>
<br>
Then when d suspends the stack of a -&gt; b -&gt; d needs to be kept until d<br>
finishes.<br>
<br>
The equivalent situation in ToonTalk is that b and c are spawned. b causes d<br>
and e to be spawned. d suspends but there is no stack to be saved.<br>
<br>
&gt;<br>
&gt;Data that belongs to an object shouldn't be a problem; the object is<br>
&gt;in charge of that data, and it ensures the atomicity of requests to<br>
&gt;use the data, which it can do because it exports the methods to access<br>
&gt;the data. It's data not belonging to an object that we have to worry<br>
about.<br>
<br>
This seems very close to what Java does. A method can be declared<br>
&quot;synchronized&quot; so it is atomic. This can easily lead to deadlocks. I don't<br>
know how frequently it will if kids are programming in such a language.<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;to a<br>
&gt;b<br>
&gt;c<br>
&gt;end<br>
&gt;<br>
&gt;to b<br>
&gt;d<br>
&gt;e<br>
&gt;end<br>
&gt;<br>
&gt;to d<br>
&gt;some code that causes this process to suspend<br>
&gt;end<br>
&gt;<br>
&gt;Then when d suspends the stack of a -&gt; b -&gt; d needs to be kept until d<br>
&gt;finishes.<br>
&gt;<br>
&gt;The equivalent situation in ToonTalk is that b and c are spawned. b causes d<br>
&gt;and e to be spawned. d suspends but there is no stack to be saved.<br>
<br>
If in fact c can't run until it gets a result from b, then instead of a lot<br>
of stack frames you have a lot of waiting spawned threads, which also take<br>
some state. Or, if all your threads really can run concurrently, you have<br>
saved thread state for context switches. In the Logo version there are at<br>
most three stack frames; in the TT version there are three thread frames<br>
(c, d, e).<br>
<br>
If the execution is truly parallel, then of course that state won't wait around as long.
But unless you're telling me that a thread as *no* state information associated with it,
I'm afraid I still don't see where the saving of memory comes in.<br>
<br>
Now, perhaps you are using a really bad memory management system in which a large chunk of
physical memory has to be located for a stack, whether or not it's used. But that isn't
the fault of stacks, or Logo, or composition of functions!<br>
<br>
And remember, nobody is arguing against concurrency here. There's no reason why, if the
tasks are independent, a Logo program couldn't say<br>
<br>
to a<br>
spawn [b]<br>
c<br>
end<br>
<br>
or whatever. What you are arguing is that the ability to do procedure calls inevitably
leads to storage loss, and I still don't see it.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a HREF="mailto:73uosj$e1s$1@agate.berkeley.edu">73uosj$e1s$1@agate.berkeley.edu</a>&gt;...<br>
&gt;If the execution is truly parallel, then of course that state won't wait<br>
&gt;around as long. But unless you're telling me that a thread has *no* state<br>
&gt;information associated with it, I'm afraid I still don't see where the<br>
&gt;saving of memory comes in.<br>
&gt;<br>
&gt;Now, perhaps you are using a really bad memory management system in which<br>
&gt;a large chunk of physical memory has to be allocated for a stack, whether<br>
&gt;or not it's used. But that isn't the fault of stacks, or Logo, or<br>
&gt;composition of functions!<br>
&gt;<br>
Implementation arguments are slippery. You seem to be arguing what is possible and I'm
arguing what is current practice. When Java died because I had a few hundred threads, I
checked news groups and talked to experts who said that is what you should expect. Now
maybe the Java implementors didn't do a very good job (and I tried it on more than one
Java implementation). But you really can have tens of thousands of threads or processes in
ToonTalk. Millions if there wasn't the overhead of the ToonTalk programming environment
(i.e. if ToonTalk supported invisible houses that couldn't be entered).<br>
<br>
I believe the Java implementation of threads is good and that within their framework it
would be too expensive to support thousands of threads. I refer to Java only because I am
more familiar with it. I believe that the cost of threads is high in all mainstream
languages that have added threads.<br>
<br>
&gt;<br>
&gt;or whatever. What you are arguing is that the ability to do procedure<br>
&gt;calls inevitably leads to storage loss, and I still don't see it.<br>
<br>
&quot;Inevitably&quot; might be too strong a word. I'm arguing it does in practice.<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;I believe the Java implementation of threads is good and that within their<br>
&gt;framework it would be too expensive to support thousands of threads. I refer<br>
&gt;to Java only because I am more familiar with it. I believe that the cost of<br>
&gt;threads is high in all mainstream languages that have added threads.<br>
<br>
That may be. What I don't believe is that the reason has to do with procedure stack
frames; I can certainly get &gt; 100,000 deep in procedure calls in Logo without trouble.
(And of course if it's a tail call, infinitely deep.)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ray Catzel:</font></p>

<p><font face="Comic Sans MS">I have a headache. I have just spent an hour (I thought Ken
deserved it for all his hard work at promoting the product) and ended by Uninstalling it
from my system (Win98). </font></p>

<p><font face="Comic Sans MS">With all this talk about special features of parallel
processing and many others I really did not comprehend, I am disappointed in the product.
If this is intuitive for elementary school kids,&nbsp; so is anything that you spend lots
of time learning how it works. </font></p>

<p><font face="Comic Sans MS">It is very visual. However, IMHO I don't think kids will
have an easier time working out how to operate a &quot;vacuum cleaner&quot; (one of the
numerous icons) than learning &quot;copy and paste&quot; concepts in Windows. </font></p>

<p><font face="Comic Sans MS">I really don't want to waste any more time on this
evaluation description. If the others on the list want to evaluate the product I can only
reassure them that the software does uninstall. </font></p>

<p><font face="Comic Sans MS">I hate to submit a critique such as this for a product that
Ken has spent so much time on. But I'm only being honest. </font></p>

<p><font face="Comic Sans MS">Have Fun!</font></p>

<p><font face="Comic Sans MS">Ray Catzel, <br>
President, ComputerPals Inc. <br>
Web site: <a HREF="http://www.computerpals.on.ca/~pals">http://www.computerpals.on.ca/~pals</a>
<br>
Email: learn@computerpals.on.ca </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp;From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">RAY CATZEL wrote<br>
<br>
&nbsp;&nbsp;&nbsp; &gt;I hate to submit a critique such as this for a product that Ken has<br>
spent so much time on. But I'm only being honest.<br>
<br>
&nbsp;&nbsp;&nbsp; I'm glad Ray downloaded the trial version and spent an hour evaluating
it. And I appreciate an honest evaluation. My opinion is far from objective but<br>
<br>
&nbsp;&nbsp;&nbsp; 1. I've collected a large number of messages from beta testers (of all
ages) who had praise for ToonTalk. (<a HREF="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>).<br>
<br>
&nbsp;&nbsp;&nbsp; 2. I've been working with a 4th grade class since January 1995. I would
say about 80% of the kids get it and like it.<br>
<br>
&nbsp;&nbsp;&nbsp; 3. One of my strongest allies, Julian Pixton, was skeptical about
ToonTalk until he watched kids use it. He is the manager of the company that is now
publishing ToonTalk in Europe, Australia, Africa, and a few other places.<br>
<br>
&nbsp;&nbsp;&nbsp; I have a theory about why kids do fine with ToonTalk, while many adults
don't. I borrowed nearly all the user interface ideas from video and computer games. There
are no Windows/Mac widgets like menus, mouse cursors, buttons, etc. Adults expecting a
conventional interface find it confusing. Kids don't.<br>
<br>
&nbsp;&nbsp;&nbsp; I urge people on this list to try the trial version themselves (<a HREF="http://www.toontalk.com/English/free.htm">www.toontalk.com/English/free.htm</a>).
And, if at all possible, watch as a kid tries it.<br>
<br>
&nbsp;&nbsp;&nbsp; Best,<br>
<br>
&nbsp;&nbsp;&nbsp; -ken<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brett Leach:</font></p>

<p><font face="Comic Sans MS">RAY CATZEL wrote:<br>
<br>
&gt; I have a headache. ...</font></p>

<p><font face="Comic Sans MS"><br>
I have to disagree with this. I downloaded ToonTalk a couple of nights ago. Woke up the
next morning and found my son (10) fascinated by TT. No instruction or anything, he just
saw the icon on my desktop and decided to check it out. I've watched him do some
incredible stuff so far.<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Wen &quot;Wayne&quot; Su:</font></p>

<p><font face="Comic Sans MS">ToonTalk, IMHO, is okay. The robot is a great idea! However,
I have one complaint about it and one suggestion. The problem is that all the objects,
such as boxes, and Pumpy, are too large. It often gets annoying where you have to scroll
around everywhere to find a particular robot. The suggestion is that there should be a
magnifying glass which would allow you to observe what's in the box. When you drop
multiple boxes into another box, often some contents are so minuscule you can't read it
well. Although you can always pump it up, a magnifier would be more handy. You can use the
glass to see what's in it. </font></p>

<p><font face="Comic Sans MS">-an 11 year old</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Wen &quot;Wayne&quot; Su wrote in message &lt;<a HREF="mailto:73fm0u$kj6$1@news-1.news.gte.net">73fm0u$kj6$1@news-1.news.gte.net</a>&gt;...<br>
ToonTalk, IMHO, is okay. ...<br>
<br>
Thanks for your post. And I like your magnifying glass idea. With high resolution graphics
it is easier to see small things. (High resolution graphics requires a 30MB file only
available on the CD-ROM.) But a magnifying glass would help even then.<br>
<br>
Best,<br>
<br>
-ken</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS"><br>
From Doug Merrill:</font></p>

<p><font face="Comic Sans MS">This is my initial evaluation of Toontalk and a comparison
with Logo. I got to Toontalk and the Logo newsgroup by typing &quot;Computer Programming
for Children&quot; into an internet search engine. I have an 8 year old son who spends
&quot;too much&quot; time playing computer games. I thought that I might get him
interested in writing his own computer games. I have MSWlogo installed and we are working
on a quiz game. His idea is to ask the user quiz questions. If the answer is wrong then
the fuse on a picture of a bomb will burn down. After a certain number of wrong answers
the bomb explodes. We have gotten a good start on making the bomb work. </font></p>

<p><font face="Comic Sans MS">Some things I really like about Logo are that it is
versatile. It looks like you can do anything with it - text, pictures, movies,
interaction. The papers at the Logo foundation web site have lots of ideas and sample
code, too. </font></p>

<p><font face="Comic Sans MS">When I first saw the demo version of Toontalk I was very
excited. My son loves computers and Legos. I enjoyed and was challenged by the puzzle
game. However, in the puzzle game and in free play I ran into some iritating problems. </font></p>

<p><font face="Comic Sans MS">1. Placing the hand and other objects in the right place is
difficult. It is hard to press the button on Dusty. It is difficult to find the right
placement of a large text object to put it in a box. Perhaps you (Ken Kahn) can put a red
dot on each object to indicate its &quot;hot spot&quot;. </font></p>

<p><font face="Comic Sans MS">2. The floor gets cluttered fast. The window gets filled
quickly with notebooks, tools, robots and birds. To get rid of a notebook I have to press
F2 to get Dusty (this takes several seconds), then put him down to check his button
setting, pick him up to suck up the notebook. Then I have to hope there is nothing
important under the notebook that gets sucked up by mistake. It would be nice to be able
to point to an object, press the delete key and have it disappear. Also when the robot is
done with the toolbox he does not put it back where he got it from (sound like anybody in
your house?). I spent some time looking for a bird only to find that the robot had put the
toolbox on top of it. A zoom feature would be nice for looking for things. That is easier
than panning across the floor, and standing up does not allow you to see objects clearly.
Perhaps you could have a toolbar instead of the tool box. A toolbar is out of the way and
won't get covered up. The user could right click on the object in the toolbar to get a new
copy and left click on the object on the toolbar to make all of those objects in the main
screen float up to the top. </font></p>

<p><font face="Comic Sans MS">3. The puzzle game was excellent for teaching me how to do
things. It got very long, however. A couple times Marty said &quot;We're almost
done&quot;, but we were not. I quit after the section on the clock and started working on
my own. But, how much did I miss? What are the upcoming topics? Is it worth my time to go
through them? I cannot find answers to these questions. The puzzle game needs a table of
contents and a way to jump to a specific section I am interested in. This brings up the
whole concept of help. Traditional Windows help has a table of contents and an index (just
like a real book). Toontalk does not have this, Logo does. When I am learning a new
computer language I want a reference book where I can look up the syntax of what I want to
do and get examples that I can cut-and-paste. But there is no cut-and-paste with Toontalk.
I have not seen the trading card manual (Is it one card for each character?), but I cannot
imagine that the cards would have enough information on them. Would they correspond to a
quick reference page? </font></p>

<p><font face="Comic Sans MS">4. This leads to a serious problem for Toontalk. I cannot
edit my program. Several times in the puzzle game I made mistakes - I did things in the
wrong order, handed the robot a box with the wrong number of holes. But I had no way to go
back and change it. This happened in the Ping-Pong demo. The programmer made the paddle
wrong. She/he had to get rid of the bad paddle and create a new one from the beginning. A
big advantage of using a text based language is that I can edit and re-use (cut-and-paste)
code. An Undo command would be very helpful while I am on the floor creating my program.
Better yet - is there someway to edit aminmation based programs? There were several times
during the puzzle game where the only way to get out of a mistake was to blow up the whole
building and start over. This seems extreme to me. I imagine children would get very
frustrated. </font></p>

<p><font face="Comic Sans MS">I showed Toontalk to my son. He looked at some of the demos
and then wanted to write his own program to make the buildings blow up. He had not paid
close attention to how it was done in the demo, but he knew it involved a bomb and a
truck. He put the bomb in the truck - Marty came to say that was not possible, bomb needed
to be in a box. (This was very good - context specific help.) My son put the bomb in a box
and the box in the truck. The truck did not move. I told my son that I thought the truck
would only move if there was a robot in it. Together we made a program that made
continuously exploding buildings. He liked going up in the helicopter and watching the
buildings explode. I asked him what he wanted to do next and he asked me if I thought we
could make an airport with airplanes taking off from it. I told him I did not think so. </font></p>

<p><font face="Comic Sans MS">This is a problem. Toontalk looks like Legos, so kids will
want to do Lego-like things with it. I don't think Lego-like things are possible - are
they? A house is not just a house, it is a metaphor for a computational process. The only
way to build a house is to create a process to happen inside it. And I have no choice in
what the house looks like. Also, all the action happens inside the houses. If I make a
city I want to be able to walk around and see things happening (like SimCity). But all I
will be able to see in Toontalk is trucks, birds and explosions (let me know if I am
wrong).</font></p>

<p><font face="Comic Sans MS">I am having a hard time imaging what I can do with Toontalk
that would interest me. The Ping-Pong game looks very crude compared to the initial
&quot;wow&quot; of the first encounter with Toontalk. How would my son make his quiz game
in Toontalk? I tried putting text on the wall of the room - it was clumsy. But then again,
Toontalk is an animated programming language, maybe it doesn't do text well. What does it
to well? I am the kind of person who needs lots of examples. </font></p>

<p><font face="Comic Sans MS">On the other hand I was blown away by the 3D examples in
MSWLogo. I want to make a sphere with land masses colored on the surface and make a GIF
movie of it (the earth) rotating. I wonder how much computer time a movie of, say, 12
frames would take. Now I understand better how computer animation is done and why
Hollywood computer animation requires lots of time and memory. Logo makes me imagine
things and wonder about things. I can imagine making a Logo airport with my son - make a
bitmap of an airport as the background, then turn the turtles into airplanes and program
them to fly. It would be 2-dimensional, not as pretty as Toontalk. But is something like
that even possible with Toontalk? </font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Doug Merrill wrote<br>
&gt;<br>
&gt;When I first saw the demo version of Toontalk I was very excited. My<br>
&gt;son loves computers and Legos. I enjoyed and was challenged by the<br>
&gt;puzzle game. However, in the puzzle game and in free play I ran into<br>
&gt;some iritating problems.<br>
&gt;<br>
&gt;1. Placing the hand and other objects in the right place is difficult.<br>
&gt;It is hard to press the button on Dusty. It is difficult to find the<br>
&gt;right placement of a large text object to put it in a box. Perhaps you<br>
&gt;(Ken Kahn) can put a red dot on each object to indicate its &quot;hot spot&quot;.<br>
&gt;<br>
A red spot would work but ToonTalk, like movies, novels, and many video games, relies upon
a &quot;suspension of disbelief&quot;. So I am wary of adding anything that might
interfere with the fantasy of being in this animated world. Selection is indicated in
ToonTalk by wiggling. An object &quot;trembles&quot; because it senses it might be picked
up, or vacuumed, or whatever. The price of innovation is that users have to learn to
notice the wiggling - there are no wide-spread conventions to rely on.<br>
<br>
&gt;2. The floor gets cluttered fast. The window gets filled quickly with<br>
&gt;notebooks, tools, robots and birds.<br>
<br>
You are right, it does. This is because everything is pretty large. You can use Pumpy to
shrink things down (and with the high resolution graphics you can shrink them quite a lot
and still use them effectively). ToonTalk will remember what size and position you like
for your tools. ToonTalk is meant to work with a wide range of users. Large objects are
appropriate for young kids and novices. Older and more experienced users learn how to
customize ToonTalk to their liking.<br>
<br>
&gt;To get rid of a notebook I have to<br>
&gt;press F2 to get Dusty (this takes several seconds), then put him down to<br>
&gt;check his button setting, pick him up to suck up the notebook. Then I<br>
&gt;have to hope there is nothing important under the notebook that gets<br>
&gt;sucked up by mistake. It would be nice to be able to point to an<br>
&gt;object, press the delete key and have it disappear.<br>
<br>
Again, I decided to try to maintain the underlying fantasy. F2 makes a sound so Dusty
comes running to you. F2 while Dusty is coming means you are impatient and he gets there
instantly. Pressing the delete key might be a nice short cut for F2, F2, space (to turn
him on), space (to turn him off). Thanks for the suggestion.<br>
<br>
&gt;Also when the robot<br>
&gt;is done with the toolbox he does not put it back where he got it from<br>
&gt;(sound like anybody in your house?). I spent some time looking for a<br>
&gt;bird only to find that the robot had put the toolbox on top of it. A<br>
&gt;zoom feature would be nice for looking for things. That is easier than<br>
&gt;panning across the floor, and standing up does not allow you to see<br>
&gt;objects clearly. Perhaps you could have a toolbar instead of the tool<br>
&gt;box. A toolbar is out of the way and won't get covered up. The user<br>
&gt;could right click on the object in the toolbar to get a new copy and<br>
&gt;left click on the object on the toolbar to make all of those objects in<br>
&gt;the main screen float up to the top.<br>
&gt;<br>
<br>
I like the fantasy that the tool box is character that follows you where you go. It also
&quot;explains&quot; why things that &quot;live&quot; in the tool box are the same no
matter what room you go to. I'll look into the problem of a robot being trained to move
the tool box covering things up - it shouldn't. Thanks for reporting it.<br>
<br>
&gt;3. The puzzle game was excellent for teaching me how to do things. It<br>
&gt;got very long, however. A couple times Marty said &quot;We're almost done&quot;,<br>
&gt;but we were not. I quit after the section on the clock and started<br>
&gt;working on my own. But, how much did I miss? What are the upcoming<br>
&gt;topics? Is it worth my time to go through them? I cannot find answers<br>
&gt;to these questions. The puzzle game needs a table of contents and a way<br>
&gt;to jump to a specific section I am interested in.<br>
<br>
A very good suggestion. I'll make a guide to the puzzle section. Thanks.<br>
<br>
&gt;This brings up the<br>
&gt;whole concept of help. Traditional Windows help has a table of contents<br>
&gt;and an index (just like a real book).<br>
<br>
There is <a HREF="http://www.toontalk.com/English/doc.htm">www.toontalk.com/English/doc.htm</a>.
You can reach a local copy on your hard disk from the Help button after starting ToonTalk.
And Marty can be called to explain anything you are holding or pointing to by pressing F1.<br>
<br>
&gt;Toontalk does not have this, Logo<br>
&gt;does. When I am learning a new computer language I want a reference<br>
&gt;book where I can look up the syntax of what I want to do and get<br>
&gt;examples that I can cut-and-paste. But there is no cut-and-paste with<br>
&gt;Toontalk.<br>
<br>
There is cut and paste (see the sensor on Page 30 of the sensor notebook). But as you
point out below, there is this issue of editing...<br>
<br>
&gt;I have not seen the trading card manual (Is it one card for<br>
&gt;each character?), but I cannot imagine that the cards would have enough<br>
&gt;information on them. Would they correspond to a quick reference page?<br>
&gt;<br>
Yes.<br>
<br>
&gt;4. This leads to a serious problem for Toontalk. I cannot edit my<br>
&gt;program. Several times in the puzzle game I made mistakes - I did<br>
&gt;things in the wrong order, handed the robot a box with the wrong number<br>
&gt;of holes. But I had no way to go back and change it. This happened in<br>
&gt;the Ping-Pong demo. The programmer made the paddle wrong. She/he had<br>
&gt;to get rid of the bad paddle and create a new one from the beginning. A<br>
&gt;big advantage of using a text based language is that I can edit and<br>
&gt;re-use (cut-and-paste) code. An Undo command would be very helpful<br>
&gt;while I am on the floor creating my program. Better yet - is there<br>
&gt;someway to edit aminmation based programs? There were several times<br>
&gt;during the puzzle game where the only way to get out of a mistake was to<br>
&gt;blow up the whole building and start over. This seems extreme to me. I<br>
&gt;imagine children would get very frustrated.<br>
&gt;<br>
<br>
The design and engineering of an editor for an animated language like ToonTalk is a big
undertaking. I have plenty of ideas. The only thing implemented is that you can retrain a
robot. If you vacuum out the contents of his thought bubble and give him a box, you'll
enter his imagination. And the robot will begin to redo what he was trained to do. At any
point you can interrupt him and take over. On the average it cuts your work in half.<br>
<br>
The funny thing is that I haven't seen kids getting frustrated redoing robots. There are
lots of times when kids voluntarily redo something over and over again until they get it
right. This is extremely common when playing video games. Kids will try over and over
again to beat a &quot;boss&quot; in Super Mario Brothers, for example.<br>
<br>
&gt;I asked<br>
&gt;him what he wanted to do next and he asked me if I thought we could make<br>
&gt;an airport with airplanes taking off from it. I told him I did not<br>
&gt;think so.<br>
&gt;<br>
&gt;This is a problem. Toontalk looks like Legos, so kids will want to do<br>
&gt;Lego-like things with it. I don't think Lego-like things are possible -<br>
&gt;are they? A house is not just a house, it is a metaphor for a<br>
&gt;computational process. The only way to build a house is to create a<br>
&gt;process to happen inside it. And I have no choice in what the house<br>
&gt;looks like. Also, all the action happens inside the houses. If I make<br>
&gt;a city I want to be able to walk around and see things happening (like<br>
&gt;SimCity). But all I will be able to see in Toontalk is trucks, birds<br>
&gt;and explosions (let me know if I am wrong).<br>
&gt;<br>
<br>
You can add objects to a city and they can have robots on the back giving them a behavior.
But the more general answer is to use the same techniques in the Ping Pong example. You
can make a combination of pictures with robots on the back giving the pictures any
behavior you like. The pictures can be the clip art included in ToonTalk or imported BMP
files. You can of course make the picture fill the screen and cover all the ToonTalk
object below.<br>
<br>
&gt;I am having a hard time imaging what I can do with Toontalk that would<br>
&gt;interest me. The Ping-Pong game looks very crude compared to the<br>
&gt;initial &quot;wow&quot; of the first encounter with Toontalk. How would my son<br>
&gt;make his quiz game in Toontalk? I tried putting text on the wall of the<br>
&gt;room - it was clumsy. But then again, Toontalk is an animated<br>
&gt;programming language, maybe it doesn't do text well. What does it to<br>
&gt;well? I am the kind of person who needs lots of examples.<br>
&gt;<br>
<br>
Text-oriented programs are possible, but I concede they are more awkward in ToonTalk. Text
can act just like a picture and be combined with other text on a background. Text input is
character-by-character (though a word or line based input robot team could be built and
put in a library). (The Examples notebook does contain a sentence generator.)<br>
<br>
Thanks for taking the time to both try ToonTalk and write a long evaluation. And thanks
for your good suggestions.<br>
<br>
Best,<br>
<br>
-ken kahn<br>
<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Wen Su sent a message to the ToonTalk discussion list (<a HREF="mailto:toontalk@lists.best.com">toontalk@lists.best.com</a>) where he brought up
questions about a sequential ToonTalk. Given the recent discussion here I thought I should
re-post his message and my reply. Wen wrote:<br>
<br>
&gt;I think I understand that the concurrency feature is at the<br>
&gt;the heart of ToonTalk. But, after reading some postings in Logo<br>
&gt;user's group, I feel it is sometimes difficult, if not impossible,<br>
&gt;for some people to like/accept the idea that there are alternative<br>
&gt;programming models than the traditional step-by-step sequetinal<br>
&gt;programming model, that may be useful under SOME situations.<br>
&gt;When I first learned to program, I myself did not learn<br>
&gt;such concepts that are typically taught in Operating System courses.<br>
&gt;<br>
&gt;For example, if some people are only interested in introducing very simple<br>
&gt;sequential programming concepts to their children, can ToonTalk, with<br>
&gt;some minor change, or &quot;coated&quot; with a thin layer of code (so that the<br>
&gt;concurrency feature, which is just TOO MUCH for them to digest now, is<br>
hidden<br>
&gt;temporarily until they are ready for this), is still useful to these<br>
people?<br>
&gt;<br>
&gt;TT's animation feature is of great helps to beginners even in the pure<br>
&gt;sequential programming context. In a sense, this is &quot;Acting Turtle&quot; but<br>
&gt;in bird's view rather than the first person view. For example, if<br>
&gt;the beginners just want to learn the program sequencing, or<br>
&gt;the &quot;if statement&quot;, or loops, we may give them &quot;preprogrammed&quot;
robots which<br>
does<br>
&gt;nothing rather than give orders to other robots (via message passing<br>
mechanism, but some<br>
&gt;actions are made invisible if appropriate).<br>
&gt;<br>
&gt;This &quot;highly-simplified, no-brainer&quot; TT may be more like an example TT<br>
program<br>
&gt;rather than the general-purpose programming environment (more or less like<br>
an emulator.)<br>
&gt;<br>
&gt;Games often provides difficulty levels. So should TT, I think.<br>
&gt;<br>
&gt;I do not know this is just my dream that just run wild, or it is feasible<br>
&gt;or desirable to provide such an emulated environment.<br>
&gt;<br>
&gt;--Regards<br>
&gt;Wen<br>
<br>
Wen brings up some interesting questions.<br>
<br>
One question is could there be a version of ToonTalk that was sequential? One might think
it would be a small change - instead of training a robot to drop a box and team of robots
into a truck, you train him to give the box to the team. We would then have replaced
process spawning by procedure calls. (Well, not quite if you also want to deal with return
values from the procedure call. You could also get rid of birds and nests and make a
version of ToonTalk where a robot left something behind when he stopped. What he left
behind could be the return value.)<br>
<br>
Would this sequential ToonTalk be easier to use or understand? Could it do as much as the
current ToonTalk? First consider what it would be like to watch a computation as robots
get hold of other robots and give them boxes to work on. It could get messy and confusing
but maybe one could work out a good way to showing what is happening (something like a
stack of waiting<br>
robots). I doubt that it would be easier to understand (unless you already had learned
some sequential programming language and expect all other languages to work in a similar
way - and most do). Then there is the problem of game or sprite programming. The Ping Pong
demo depends critically on the ball, paddle, and score keeper running in parallel - how
would such a thing be programmed in a sequential ToonTalk? (Of course, it is possible to
simulate parallelism within a sequential ToonTalk but that is messy and confusing.)<br>
<br>
I agree with Wen that it is difficult for some people (adults) to like/accept
non-sequential programming. And they may prefer teaching kids sequential languages. But I
believe kids who have never programmed expect computations to be concurrent. The world
around them is concurrent - cars are driving, birds are flying, kids are playing soccer,
and so on. They can walk and talk at the same. And forces are concurrent - they toss a
ball on a windy day and both gravity and the wind act upon it. What is natural about
sequential procedure calls?<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;I agree with Wen that it is difficult for some people (adults) to<br>
&gt;like/accept non-sequential programming. And they may prefer teaching kids<br>
&gt;sequential languages. But I believe kids who have never programmed expect<br>
&gt;computations to be concurrent. The world around them is concurrent - cars<br>
&gt;are driving, birds are flying, kids are playing soccer, and so on. They can<br>
&gt;walk and talk at the same. And forces are concurrent - they toss a ball on a<br>
&gt;windy day and both gravity and the wind act upon it. What is natural about<br>
&gt;sequential procedure calls?<br>
<br>
My question is, why does it have to be either/or? StarLogo is about as parallel as a
language can get, but it still allows composition of functions where that's appropriate.<br>
<br>
When kids play games, there are lots of sequential things that happen. First you hit the
ball, then you run around the bases. I think this business about sequential VERSUS
parallel is a red herring. The question is why you feel the need to throw 3,000 years of
mathematics out the window just because you have a new idea -- can't you still remember
the old ideas? (Just in case it's not obvious, the 3,000 years are about composition of
functions.)<br>
<br>
In fact, from my point of view, it's particularly ironic that you use
&quot;sequential&quot; as a dirty word, since TT is much *more* sequential than any other
programming language I've ever seen, even BASIC. Where I can say<br>
(2+3) * (4+5)<br>
putting my focus on the answer I want, you have to say<br>
pick up a 2<br>
put it in a box<br>
pick up a 3<br>
put it on top of the box<br>
wait a few minutes while they get bammed together<br>
now put that down and pick up another box<br>
pick up a 4<br>
put it in a box<br>
pick up a 5<br>
put it on top of the box<br>
wait a few more minutes<br>
get the 9 out of the box<br>
somehow (I haven't gotten that far yet) put a times sign<br>
in front of it<br>
now pick up the 5 from the 2+3<br>
put it on the X9<br>
wait some more<br>
You call that not sequential?</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6">&nbsp;</font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a HREF="mailto:73phsa$218$1@agate.berkeley.edu">73phsa$218$1@agate.berkeley.edu</a>&gt;...<br>
&gt;<br>
&gt;My question is, why does it have to be either/or? StarLogo is about as<br>
&gt;parallel as a language can get, but it still allows composition of<br>
&gt;functions where that's appropriate.<br>
&gt;<br>
&gt;When kids play games, there are lots of sequential things that happen.<br>
&gt;First you hit the ball, then you run around the bases. I think this<br>
&gt;business about sequential VERSUS parallel is a red herring. The question<br>
&gt;is why you feel the need to throw 3,000 years of mathematics out the<br>
&gt;window just because you have a new idea -- can't you still remember the<br>
&gt;old ideas? (Just in case it's not obvious, the 3,000 years are about<br>
&gt;composition of functions.)<br>
&gt;<br>
<br>
I happen to think functional composition is a red herring. It is only a SYNTATIC issue.
Consider computing the number of seconds in a day. You can use functional composition and
enter an expression like<br>
<br>
(* hours_in_a_day (* minutes_in_an_hour seconds_in_a_minute))<br>
<br>
or you can avoid functional composition and write<br>
<br>
(let ((seconds_in_an_hour (* minutes_in_an_hour seconds_in_a_minute))<br>
(* hours_in_a_day seconds_in_an_hour)<br>
)<br>
<br>
I don't see this as a big issue. One could even argue that the second way is a better
programming style since you name intermediate results. And logic and relations are at
least as old as functions. Functions are just a special case of relations that are
many-to-one.<br>
<br>
&gt;In fact, from my point of view, it's particularly ironic that you use<br>
&gt;&quot;sequential&quot; as a dirty word, since TT is much *more* sequential than<br>
&gt;any other programming language I've ever seen, even BASIC. Where I can<br>
&gt;say<br>
&gt; (2+3) * (4+5)<br>
&gt;putting my focus on the answer I want, you have to say<br>
&gt; pick up a 2<br>
&gt; put it in a box<br>
&gt; pick up a 3<br>
&gt; put it on top of the box<br>
&gt; wait a few minutes while they get bammed together<br>
&gt; now put that down and pick up another box<br>
&gt; pick up a 4<br>
&gt; put it in a box<br>
&gt; pick up a 5<br>
&gt; put it on top of the box<br>
&gt; wait a few more minutes<br>
&gt; get the 9 out of the box<br>
&gt; somehow (I haven't gotten that far yet) put a times sign<br>
<br>
Type x, X, or * while holding the 9.<br>
<br>
&gt; in front of it<br>
&gt; now pick up the 5 from the 2+3<br>
&gt; put it on the X9<br>
&gt; wait some more<br>
&gt;You call that not sequential?<br>
<br>
Yes, it is expressed sequentially. But this style is only when using primitive operations
like arithmetic. (And since pure arithmetic is very easy to parallelize this could run in
parallel in principle.) A purist could train a robot to take a box with 2 numbers and
bird, combine the numbers appropriately and give the bird the result. You can then program
(2+3) * (4+5) by loading up trucks with this robot so it does run in parallel. This is
sometimes a better style. It is used in the doubly recursive version of factorial (see <a HREF="http://www.toontalk.com/English/programs.htm">www.toontalk.com/English/programs.htm</a>).)<br>
<br>
ToonTalk provides an &quot;immediate mode&quot; version of arithmetic because I believe it
is easier (and more fun since Bammer the Mouse is popular with kids). But the computer
scientist in me thinks I shouldn't have made a special case of arithmetic when it wasn't
strictly necessary. Prolog, by the way, also provides a special syntax for arithmetic that
isn't strictly necessary.<br>
<br>
It is true that you hit the ball before you run around the bases. The design question here
is whether you make a more complex language and implementation and support both parallel
and sequential executions or not. I chose to keep things simple. So to program this you
need to have the part of the program that decides that a ball is hit to give a bird a
token indicating that the ball has been hit. The part of the program for running around
the bases has to be waiting for that token to arrive before starting. It is not that hard
to express things this way.<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt;It is true that you hit the ball before you run around the bases. The design<br>
&gt;question here is whether you make a more complex language and implementation<br>
&gt;and support both parallel and sequential executions or not. I chose to keep<br>
&gt;things simple.<br>
<br>
I think this may be the core of our disagreement. It's not quite clear from that sentence
whether you mean &quot;simple for the implementor&quot; or &quot;simple for the
user.&quot; If the former, we disagree in principle. If the latter, we disagree about user
interface strategy. I'm not convinced that simplicity means &quot;give the user a hammer
and teach him that everything is a nail&quot;!<br>
<br>
You started this whole discussion by saying that computer science has moved on since Logo,
and we should support new paradigms. So I think it's worth noting that the mainstream
languages that support parallelism and OOP haven't thrown out other expressive mechanisms;
afaik that's unique to TT.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a HREF="mailto:73unos$dlc$1@agate.berkeley.edu">73unos$dlc$1@agate.berkeley.edu</a>&gt;...<br>
&gt;<br>
&gt;I think this may be the core of our disagreement. It's not quite clear<br>
from<br>
&gt;that sentence whether you mean &quot;simple for the implementor&quot; or &quot;simple
for<br>
&gt;the user.&quot; If the former, we disagree in principle. If the latter, we<br>
&gt;disagree about user interface strategy. I'm not convinced that simplicity<br>
&gt;means &quot;give the user a hammer and teach him that everything is a nail&quot;!<br>
&gt;<br>
<br>
I do mean the user. Though I would like advanced users to have a good idea of how things
are implemented. Don't Scheme and Lisp courses teach students how to write
meta-interpreters? That is a lot harder to do if the language isn't simple.<br>
<br>
When I first came to Xerox PARC (1984) I became heavily involved in a multi-paradigm
language project (called Loops, then InterLoops, then CommonLoops, and I dropped out when
it became CLOS). I recall reviewing a paper written at Bell Labs that argued persuasively
that there were very large cognitive and collaborative costs to using such rich languages.
I became convinced that it is hard for most people to switch between different programming
paradigms at the fine-grain that these languages enable. And the author of the paper
reported on the problems teams at Bell Labs had due to different members using very
different ways of programming. Team members found it hard to understand and modify each
other's code.<br>
<br>
Also there can be interference between the parts. A Prolog-like, logic programming,
component has troubles integrating well with an imperative sub-language. A pure functional
component permits all sorts of program transformations and parallel executions that break
when integrated with languages with side-effects.<br>
<br>
&gt;You started this whole discussion by saying that computer science has moved<br>
&gt;on since Logo, and we should support new paradigms. So I think it's worth<br>
&gt;noting that the mainstream languages that support parallelism and OOP haven't<br>
&gt;thrown out other expressive mechanisms; afaik that's unique to TT.<br>
<br>
Yes, the mainstream has just added parallelism to existing frameworks. And professional
programmers have a hard time understanding and debugging Java programs with threads (and
Java is one of the better examples of this). Computer scientists continue to explore
actor, functional, logic-based, and constraint-based programming languages that, like
ToonTalk, throw out some old ideas in order to make progress. In contrast, the computer
industry or mainstream just tries to graft new things on the old.<br>
<br>
This news group is about Logo - about powerful programming languages for kids. Unlike the
mainstream, the constraints of legacy systems and backwards compatibility are minimal. And
we can give kids the ability to make parallel programs without forcing them to master the
complexity of locks and atomic regions. And without expecting them to debug race
conditions and deadlocks.<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt; I recall reviewing a<br>
&gt;paper written at Bell Labs that argued persausively that there were very<br>
&gt;large cognitive and collaborative costs to using such rich languages. I<br>
&gt;became convinced that it is hard for most people to switch between different<br>
&gt;programming paradigms at the fine-grain that these languages enable.<br>
<br>
I guess I'd like to know whether all paradigms are equally hard in this sense. My teaching
experience has made me (reluctantly!) conclude that sequential programming is most natural
for most people, and that functional programming takes more mental effort (although the
effort does pay off dramatically). Where is concurrent programming on that scale? What is
the marginal cost of keeping function composition in a language, on that scale, versus the
marginal cost of including concurrency?<br>
<br>
&gt;Also there can be interference between the parts. A Prolog-like, logic<br>
&gt;programming, component has troubles integrating well with an imperative<br>
&gt;sub-language. A pure functional component permits all sorts of program<br>
&gt;transformations and parallel executions that break when integrated with<br>
&gt;languages with side-effects.<br>
<br>
I was with you on the logic programming example, but the functional one seems to me to be
a bit of sleight-of-hand; there you are talking about complexity for the implementor, not
cognitive load for the user.<br>
<br>
&gt;Yes, the mainstream has just added parallelism to existing frameworks. And<br>
&gt;professional programmers have a hard time understanding and debugging Java<br>
&gt;programs with threads (and Java is one of the better examples of this).<br>
&gt;Computer scientists continue to explore actor, functional, logic-based, and<br>
&gt;constraint-based programming languages that, like ToonTalk, throw out some<br>
&gt;old ideas in order to make progress. In contrast, the computer industry or<br>
&gt;mainstream just tries to graft new things on the old.<br>
<br>
I'm convinced that it's difficult to debug programs that combine concurrency with mutation
of shared variables. I'm not convinced, yet, that you can't have all of<br>
* concurrency<br>
* composition of functions without mutation<br>
* mutation of local (not shared) variables<br>
all in the same language, without trouble.<br>
<br>
P.S. In Scheme we can do functional, sequential, concurrent, and OOP, even though Scheme
is, in at least one sense, a very simple language. It doesn't have millions of primitives,
like CLOS, or a lot of syntax, like Java. We try to teach our students to be able to use
several programming paradigms, but to pay attention to which one they're using. I suspect
that those programmers you mention who had confusingly mixed styles were handed a Common
Lisp manual with no explicit instruction about paradigms at all.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a HREF="mailto:73v2ml$lk6$1@agate.berkeley.edu">73v2ml$lk6$1@agate.berkeley.edu</a>&gt;...<br>
&gt;I guess I'd like to know whether all paradigms are equally hard in this<br>
&gt;sense. My teaching experience has made me (reluctantly!) conclude that<br>
&gt;sequential programming is most natural for most people, and that<br>
&gt;functional programming takes more mental effort (although the effort<br>
&gt;does pay off dramatically). Where is concurrent programming on that<br>
&gt;scale? What is the marginal cost of keeping function composition in<br>
&gt;a language, on that scale, versus the marginal cost of including<br>
&gt;concurrency?<br>
&gt;<br>
<br>
Very good questions! Does anyone know of research trying to answer these types of
questions? Either in the computers and education literature or the psychology of
programming? (The only thing I can think of is Mitch Resnick's masters thesis on
MultiLogo.)<br>
<br>
&gt;&gt;A pure functional component permits all sorts of program<br>
&gt;&gt;transformations and parallel executions that break when integrated with<br>
&gt;&gt;languages with side-effects.<br>
&gt;<br>
&gt;the functional one<br>
&gt;seems to me to be a bit of sleight-of-hand; there you are talking about<br>
&gt;complexity for the implementor, not cognitive load for the user.<br>
&gt;<br>
<br>
How about concern for the order of execution of the arguments to a function? In the pure
case, you needn't bother yourself about this. If there might be side-effects, you now have
one more thing to keep in mind.<br>
<br>
&gt;<br>
&gt;I'm convinced that it's difficult to debug programs that combine<br>
&gt;concurrency with mutation of shared variables. I'm not convinced, yet,<br>
&gt;that you can't have all of<br>
&gt; * concurrency<br>
&gt; * composition of functions without mutation<br>
&gt; * mutation of local (not shared) variables<br>
&gt;all in the same language, without trouble.<br>
&gt;<br>
I'm not sure either. We'll just have to wait for someone to build it (or at least design
it in detail). But you'll agree that there is no dialect of Logo that satisfies those
criteria, right?<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a HREF="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt; But you'll agree that there is no dialect of<br>
&gt;Logo that satisfies those criteria, right?<br>
<br>
Yes, I agree with that. (Although we really should look back at TLC Logo and RM Logo to
see how they handled concurrency issues.)<br>
<br>
What's making me so curmudeonly about TT is that with new software these days I always
seem to have to give up three things to get one new thing, and, while I've learned to
expect this from the likes of Microsoft, I don't want to have to put up with it from my
friends! :-)</font></p>

<p><font face="Comic Sans MS">&nbsp;<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a HREF="mailto:740836$i2l$1@agate.berkeley.edu">740836$i2l$1@agate.berkeley.edu</a>&gt;...<br>
&gt;<br>
&gt;What's making me so curmudeonly about TT is that with new software<br>
&gt;these days I always seem to have to give up three things to get one<br>
&gt;new thing, and, while I've learned to expect this from the likes of<br>
&gt;Microsoft, I don't want to have to put up with it from my friends! :-)<br>
<br>
I see the arithmetic a bit differently:<br>
<br>
Logo - synchronous procedure calls - global variables - sequential execution - functional
composition + concurrent execution + asynchronous procedure calls + animated programming
environment + demonstrative programming + objects + many-to-many communication channels =
(approximately) ToonTalk<br>
<br>
Most of our discussion has been me been arguing why the things I've added are good and why
I felt the need to remove the things I did. And you have been arguing I shouldn't have
removed those things.<br>
<br>
Best,<br>
<br>
-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Wen &quot;Wayne&quot; Su:</font></p>

<p><font face="Comic Sans MS">Ken Kahn wrote in message<br>
&gt;I see the arithmetic a bit differently:<br>
&gt;<br>
&gt;Logo - synchronous procedure calls - global variables - sequential<br>
&gt;execution - functional composition + concurrent execution + asynchronous<br>
&gt;procedure calls + animated programming environment + demonstrative<br>
&gt;programming + objects + many-to-many communication channels =<br>
&gt;(approximately) ToonTalk<br>
<br>
<br>
Although I may not know all these concepts well, I enjoy reading discussions among members
in this news group. Although I have no clear ideas about what combinations of language
features are good for elementary/middle schoolers, there is definitely something new or
interesting to me in TT that makes me think.<br>
<br>
Today, I find out that it seems there is no explicit variable identifier in TT as we have
in typical, text based computer languages, in which we use a character string to identify
a variable at programming or coding time. What seems to be a variable in TT is not
explicitly given a name; it is just the &quot;thing&quot; you see on the screen, which you
can put a thing into it.</font></p>

<p><font face="Comic Sans MS">If this is true, does this mean you can teach kids who do
not know how to spell words yet to understand the concept of variable? I guess not. I
think for kids who are too young to learn to spell, some features in TT should be
temporarily disabled but some features are still age-appropriate.<br>
<br>
About the concurrency issue, it is important in SOME context, and those kids who may
become computer engineers definitely need to learn these techniques/concepts sooner or
later (But I do not know how soon.) All hardware description languages used to design
microprocessors are concurrent in nature. A major architecture difference between an Intel
486 microprocessor and a Pentium microprocessor is the latter executes instructions more
concurrently. There are more concurrency issues that need to be addressed for the next
generation CPU (More concurrency logic is going to be in the software compiler rather than
the chips, though.) The question is whether or not most of us still keep programming in
sequential languages, and let a selected few build the concurrent system for us. But there
is a need to let at least some children learn these concepts.<br>
<br>
&gt;Most of our discussion has been me been arguing why the things I've added<br>
&gt;are good and why I felt the need to remove the things I did. And you have<br>
&gt;been arguing I shouldn't have removed those things.<br>
&gt;<br>
&gt;Best,<br>
&gt;<br>
&gt;-ken kahn (<a HREF="http://www.toontalk.com/">www.toontalk.com</a>)<br>
&gt;<br>
&gt;<br>
<img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Wen \&quot;Wayne\&quot; Su&quot; &lt;<a href="mailto:Wen.Su@gte.net">Wen.Su@gte.net</a>&gt; writes:<br>
&gt;The question is whether or not most of us still keep programming in<br>
&gt;sequential languages, and let a selected few build the concurrent system<br>
&gt;for us. But there is a need to let at least some children learn these<br>
&gt;concepts.<br>
<br>
I don't think the design of Logo, or TT, should or does revolve around the future needs of
the computer industry!&nbsp; My own CS-in-Logo books are an anomaly; the features we put
in languages for kids are chosen to support their general intellectual development, we
hope, and more specifically to turn them into mathematicians (by which I mean formal
thinkers).<br>
<br>
The ones who will end up programming will learn what they need to learn somewhere along
the line.</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Wen Su:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:744o1t$ofl$1@agate.berkeley.edu">744o1t$ofl$1@agate.berkeley.edu</a>&gt;...<br>
&gt;&quot;Wen \&quot;Wayne\&quot; Su&quot; &lt;<a href="mailto:Wen.Su@gte.net">Wen.Su@gte.net</a>&gt;
writes:<br>
&gt;&gt;The question is whether or not most of us still keep programming in<br>
&gt;&gt;sequential languages,<br>
&gt;<br>
&gt;I don't think the design of Logo, or TT, should or does revolve around<br>
&gt;the future needs of the computer industry!&nbsp; My own CS-in-Logo books are<br>
&gt;an anomaly; the features we put in languages for kids are chosen to<br>
&gt;support their general intellectual development, we hope, and more<br>
&gt;specifically to turn them into mathematicians (by which I mean formal<br>
&gt;thinkers).<br>
<br>
Well said.<br>
<br>
I heard in most college adimissions process, a computer science course is considered as a
&quot;solid&quot; course, but a programming course is not considered as solid as a
computer science course. Is this true? There must be some reasons.<br>
<br>
When I first learned to program (in FORTRAN IV), I thought programming was not very fun.
Later, when I was learning data structures (from the book &quot;The Art of Computer
Programming&quot; by Knuth, This was probably the only data structure book available at
that time, I think.), I started to understand that there is really something interesting
in this field --even though a pure education computer language called MIX is used in that
book to describe algorithms in details.<br>
<br>
Maybe students today do not learn these things from such an old book, especially if they
learn that its author once wrote an article: &quot;Goto statements considered not
harmful&quot; or something like that. (Just joking here.)<br>
<br>
Having left schools for such a long time makes me forget what should be learned in school.
At least I would not try to introduce C/C++ or BASIC to my kid who is still in the
elementary school; so I still have some common sense, I think.<br>
<br>
Thanks for reminding me what kind of learning is important in education.<br>
<br>
--Wen Su</font><br>
<br>
<font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font><br>
</p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Wen &quot;Wayne&quot; Su wrote in message &lt;<a href="mailto:742fo9$2vi$1@news-2.news.gte.net">742fo9$2vi$1@news-2.news.gte.net</a>&gt;...<br>
&gt;<br>
&gt;Today, I find out that it seems there is no explicit variable identifier in<br>
&gt;TT as we have in typical, text based computer languages, in which we use<br>
&gt;a character string to identify a variable at programming or coding time.<br>
&gt;What seems to be a variable in TT is not explicitly given a name;<br>
&gt;it is just the &quot;thing&quot; you see on the screen, which you can put a thing into<br>
&gt;it.<br>
&gt;If this is true, does this mean you can teach kids who do not know how<br>
&gt;to spell words yet to understand the concept of variable? I guess not.<br>
&gt;I think for kids who are too young to learn to spell, some features in TT<br>
&gt;should be temporarily disabled but some features are still age-appropriate.<br>
&gt;<br>
<br>
The few times that I've watched 4 or 5 year olds use ToonTalk, I didn't see that they had
any problem with the concept of variables in ToonTalk. They understand the concept that a
box can have several holes or compartments. They know that if hole #1 is empty and they
put something in it (let's call it A) and put something else in hole #2 (let's call it B)
then if they come back to that box and take something out of hole #2 they'll get B. They
understand they can then fill the hole with a new thing (C) and it'll be there if they
come back. Holes in boxes really are equivalent to variables. Just because they might not
understand the abstraction of variables, they<br>
can program just fine by putting things into and taking them out of holes in a box. So why
disable this for young children?<br>
<br>
&gt;The question is whether or not most of us still keep programming in<br>
&gt;sequential languages, and let a selected few build the concurrent system<br>
&gt;for us. But there is a need to let at least some children learn these<br>
&gt;concepts.<br>
&gt;<br>
<br>
I agree with Brian Harvey that the primary motivation here isn't job training. ToonTalk is
concurrent because I think concurrency is a better way to think about programming.
Consider the ToonTalk Ping Pong game example. In ToonTalk, the ball is programmed to
bounce, make sounds, and communicate with the score keeper. The paddle is programmed to
follow vertical movements of the mouse. The score keeper waits for messages indicating a
change and updates itself accordingly. I think, and I think nearly everyone who is a<br>
non-programmer thinks, that it is completely natural and expected that these 3 processes
are happening concurrently. (Maybe even that the 3 behaviors of the ball are 3 processes.)
Contrast this with how in a sequential program one thinks about this. One has a top-level
loop which reads mouse movements, then updates the paddle position, then it computes a new
position for the ball, checks if it is colliding and if so computes a new velocity, it
then checks if the ball has missed the paddle and if so updates the score. And<br>
then it redisplays the paddle, ball, and score before repeating the top level loop. I
believe this is natural only to programmers who have become used to dealing with a single
thread of execution.<br>
<br>
In Mitch Resnick's masters thesis, he relates a story of a girl he was trying to teach
MultiLogo. The girl had mastered sequential Logo the year before. She kept ignoring
MultiLogo's concurrency primitives and kept programming in a sequential manner. Mitch then
asked her how she and her brother would prepare dinner for the family. She said she would
stir the pot once, tell her brother to put down a fork, then she would stir it again, and
tell him to put down a spoon. Then she realized how absurd this was and began to
understand what Mitch was saying about concurrent programming. [Disclaimer: I read his
masters thesis several years ago - and may not be remembering this story accurately.]<br>
<br>
Best,<br>
<br>
-ken</font><br>
<br>
<br>
<font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">Brian Harvey:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt; Contrast this with how in a sequential program<br>
&gt;one thinks about this. One has a top-level loop which reads mouse movements,<br>
&gt;then updates the paddle position, then it computes a new position for the<br>
&gt;ball, checks if it is colliding and if so computes a new velocity, it then<br>
&gt;checks if the ball has missed the paddle and if so updates the score. And<br>
&gt;then it redisplays the paddle, ball, and score before repeating the top<br>
&gt;level loop.<br>
<br>
I don't think this is quite fair.&nbsp; You are assuming that the sequential language has
lower-level graphics primitives than the concurrent one, I think.&nbsp; Remember Atari
Logo?&nbsp; It was sort of &quot;semi-concurrent&quot;; you programmed it sequentially,
but could set up daemons to detect collisions and joystick movement asynchronously. &nbsp;
And turtles could have speeds. The part about first checking the ball position and then
updating the score is true, though.&nbsp; So, once again, my question is not &quot;is
there any virtue to concurrency?&quot; (clearly yes) but rather &quot;do we have to give
up procedure calling and make everything fit into the Procrustean (sp?) bed of
threads?&quot;&nbsp; Maybe there is a more incremental change possible.</font><br>
<br>
<font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:74ceon$4fn$1@agate.berkeley.edu">74ceon$4fn$1@agate.berkeley.edu</a>&gt;...<br>
<br>
&gt;Remember Atari Logo?&nbsp; It was sort of &quot;semi-concurrent&quot;; you<br>
&gt;programmed it sequentially, but could set up daemons to detect collisions<br>
&gt;and joystick movement asynchronously.&nbsp; And turtles could have speeds.<br>
&gt;The part about first checking the ball position and then updating the<br>
&gt;score is true, though.&nbsp; So, once again, my question is not &quot;is there any<br>
&gt;virtue to concurrency?&quot; (clearly yes) but rather &quot;do we have to give up<br>
&gt;procedure calling and make everything fit into the Procrustean (sp?) bed<br>
&gt;of threads?&quot;&nbsp; Maybe there is a more incremental change possible.<br>
<br>
I do remember Atari Logo and was excited about it at the time.<br>
<br>
I think the core of our friendly disagreement is that I want a kind of uniformity. The
approach of Atari Logo was to provide support for some common special cases. But it didn't
give you support for others. Nor did it provide a smooth transition from built-in
concurrency to the user defined. A demon can wait for a collision and then run some
procedure. But can a demon wait for some user defined condition? I don't think so. I favor
a uniformly concurrent model of computation because it subsumes sequential procedure<br>
calls. I don't give up on them, I just don't provide any support. But a ToonTalk user can
express a sequential synchronous procedure call - by training a robot to load up a truck
with robots and box with a bird and then arranging for the team of robots to wait until
the one of the robots that was put in the truck gives the bird the &quot;return
value&quot;. Admittedly, it is more awkward than in other kinds of languages.<br>
<br>
As a language designer, one is often faced with the question of whether to give primitive,
low-level support for common special cases of what a more general mechanism can do. Doing
so will make some programs easier to express, but is likely to add complexity (for the
learner, user, and implementer). I believe a novice will find it easier to deal with
computations that are concurrent than computations which have both concurrent and
sequential parts.<br>
<br>
Best,<br>
<br>
-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)</font><br>
<br>
<font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From <a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a>:</font></p>

<p><font face="Comic Sans MS"><br>
disclaimer: I haven't seen Toon Talk.&nbsp; I don't use Windows.<br>
<br>
conjecture: Toon Talk is not capable of serving as a development<br>
environment for all applications one will ever wish to create.&nbsp; that<br>
is, anyone who keeps programming long enough, and keeps making more<br>
and more complex and/or functional programs will, eventually,<br>
&quot;outgrow&quot; Toon Talk.<br>
<br>
this is based entirely on my observation of the conversation in this<br>
newsgroup so far, and a few visits to the Toon Talk web site.<br>
<br>
if this conjecture is correct, I would be curious as to when/how you<br>
(Ken Kahn) would expect a child who kept &quot;doing more&quot; to &quot;outgrow&quot;<br>
Toon Talk.&nbsp; I would also be curious as to where you would recomend<br>
they go when this happened.&nbsp; perhaps another way of putting this is:<br>
you clearly view Toon Talk as a &quot;first step&quot; in a progression... what<br>
else do you see in that progression?<br>
<br>
if this conjecture is incorrect, I would very much like to know your<br>
reasoning as to why/how.<br>
<br>
part of the reason I'm asking this is the same reason I started<br>
following this newsgroup a couple weeks ago.&nbsp; I'm trying to understand<br>
this amorpheous concept of &quot;easy&quot; as applied to computer use and<br>
programming.&nbsp; also, can you name any other environments which share<br>
what you believe to be Toon Talk's most essential features?<br>
<br>
* warning, the part below is a long description of my personal search for<br>
* enlightenment.&nbsp; it's longer than I intended, and is mostly<br>
* questions...<br>
* it's also directed at anyone who'll listen, rather than just Ken Kahn<br>
<br>
I've dealt with many clients who are trying to learn perl so they can<br>
write CGIs, and I came to the conclusion early on that perl, while<br>
terribly convenient for many applications, is a lousy first language<br>
(even for adults).&nbsp; well, these people would, naturally, be happy<br>
writing in any other language... preferably the &quot;easiest&quot; one for<br>
them...&nbsp; so I started trying to come up with something I could recomend<br>
as an alternative to perl...<br>
<br>
when I asked many months ago on comp.lang.perl.misc &quot;is perl a good<br>
first language?&quot;, I got responses which mostly echoed my own thoughts.<br>
namely: it is not a good first language, and the main reason was<br>
because it is incredibly inconsistent.&nbsp; someone learns a &quot;rule&quot;, and<br>
then they keep getting nailed by exceptions to that rule, until they<br>
have more or less memorized all of the exceptions.&nbsp; much like english<br>
spelling.<br>
<br>
...so I figured out that consistency is an important part of something<br>
being &quot;easy&quot;, but I know there's other things.<br>
<br>
I like awk myself, and use it for many things, since it has a high<br>
degree of consistency, but beginners seem to have trouble wrapping<br>
their minds around the whole &quot;implicit loop&quot; thing (for perl users,<br>
awk always has the behavior perl has with the -n option).&nbsp; awk was<br>
designed to allow an advanced user to do a medium level custom<br>
filtering job on a file with one line of code.&nbsp; other things came as<br>
conveniences, and the authors admit it wasn't designed to be a &quot;first<br>
language&quot; (though they don't offer any thoughts on what would be better).<br>
there's a lesson here, but I don't know what it is...&nbsp; don't start<br>
with a specialized language?<br>
<br>
BASIC (is that a bad word here?), as I learned it on the apple II, is<br>
a very consistent language.&nbsp; it is also &quot;easy&quot; to grasp at first, but<br>
once a programmer starts trying to do anything requiring more than a<br>
couple thought processes to execute, he finds himself in spaghetti<br>
code.&nbsp; then he finds gosub/return, which takes care of him up to maybe<br>
one or two hundred lines or so, but then he starts having problems<br>
with all variables being global(!).&nbsp; and by then, he can have habits<br>
which are hard to break when he finds a language with dynamic scoping<br>
(oh cool!) or lexical scoping (wow!), or a while loop.&nbsp; I *hated*<br>
having to use whiles instead of gotos when I first was learning C.&nbsp; I<br>
had learned to use gotos in DCL rather than BASIC, but I can empathize<br>
with the BASIC programmer unlearning the same bad habbit.&nbsp; I think the<br>
lesson here is that while gotos are easy, they should be left out of<br>
(or at least not encouraged) in a first language.<br>
<br>
C++, like perl, has all sorts of &quot;magic&quot; in it... the same expression<br>
can mean all sorts of things depending on the context...<br>
<br>
I think C is a better first language than C++ because it has so much<br>
less &quot;magic&quot;, but string handling is such a pain to do right in C,<br>
and so dangerous to do wrong... it seems wrong to me to teach budding<br>
programmers dangerous practices like:<br>
<br>
main()<br>
{<br>
char name[100];<br>
<br>
printf(&quot;What is your name? &quot;);<br>
scanf(&quot;%s&quot;, name);<br>
printf(&quot;Hello %s!\n&quot;, name);<br>
}<br>
<br>
but the alternative is to make them do it the correct way.&nbsp; and to<br>
write a safe version of the above, I can't think of anything simpler than:<br>
<br>
main()<br>
{<br>
char name[100];<br>
int i;<br>
<br>
printf(&quot;What is your name? &quot;);<br>
fgets(name, 100, stdin);<br>
name[99] = '\0';<br>
<br>
for(i=0; i &lt; 100; ++i)<br>
&nbsp; if(name[i] == ' ' || name[i] == '\t' || name[i] == '\n')<br>
&nbsp; {<br>
&nbsp;&nbsp; name[i] = '\0';<br>
&nbsp;&nbsp; break;<br>
&nbsp; }<br>
<br>
printf(&quot;Hello %s!\n&quot;, name);<br>
<br>
but this isn't a suitable &quot;second&quot; program, the way the above is... it<br>
doesn't have just input and output.&nbsp; it also has conditionals, loops,<br>
character constants, strings-as-null-terminated-arrays-of-chars, etc.<br>
<br>
while in my search for understanding with respect to what makes a good<br>
first language, and what makes something &quot;easy&quot;, I saw a manual for<br>
AppleLogoII at the local friends of the library book sale.&nbsp; I happen<br>
to own several Apple IIs (love the things, and they serve as a<br>
constant reminder to me of why I use Linux.&nbsp; no one company or person<br>
can kill Linux the way Apple killed the Apple II.&nbsp; but I digress.)<br>
thinking &quot;hay, logo's for kids.&nbsp; it must be easy.&nbsp; maybe it would make<br>
a good case study.&quot;, I bought it, picked myself up a copy of<br>
AppleLogoII, and started learning it.&nbsp; frankly, it just reminded me of<br>
elisp (the only lisp dialect I am very familiar with, though I know a<br>
*teeny* bit of scheme) with some different names, and '(...) replaced<br>
with [...] and '... replaced with &quot;... .<br>
<br>
all the same concepts... recursion, variables, itteration via tail<br>
recursion, minus things like non-argument local variables.<br>
<br>
now, I've played with ucblogo, and I've seen many of the improvements<br>
and enhancements in it, but I still don't get what I came trying to<br>
understand...<br>
<br>
-&gt; what is it about logo (or any other language) that is supposed to make<br>
-&gt; it &quot;easy&quot;, and good as a first language?<br>
<br>
-&gt; how is it that logo (or any other language) allows people to &quot;easily&quot;<br>
-&gt; express to the computer their thought process?<br>
<br>
I think I (more of less) understand how Toon Talk acomplishes these,<br>
based on Ken Kahn's multitude of kind explanations, but I'm curious<br>
about how he or anyone else would suggest someone move from the Toon<br>
Talk world into something more useful, and where an adult should<br>
begin this same journey.<br>
<br>
perhaps I'm just a little bit lost in trying to understand the best<br>
progression for a learning programmer since my first language was DCL.<br>
you could say I had a broken programmer's childhood and am now trying<br>
to understand what a healthy one is like :-)<br>
<br>
my apologies if I have gone too far off topic for this group...&nbsp; I'm<br>
certainly interested in hearing about any other more or equally<br>
appropriate places to bring up these questions.<br>
<br>
I guess at the heart of it, I'm trying to figure out, in general,<br>
what's the best answer to &quot;I want to learn how to program.&nbsp; where<br>
should I start?&quot;, and in particular, what's the best answer to &quot;I want<br>
to write CGIs for my web site.&nbsp; where should I start learning?&quot;.&nbsp; I'm<br>
also, however, trying to get a handle on what it means for a language<br>
or programming environment to be &quot;intuitive&quot; or &quot;easy&quot;.<br>
<br>
andru</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>
<a href="mailto:luvisi@andru.sonoma.edu">

<p><font face="Comic Sans MS">luvisi@andru.sonoma.edu</a> wrote in message ...<br>
<br>
&gt;conjecture: Toon Talk is not capable of serving as a development<br>
&gt;environment for all applications one will ever wish to create.&nbsp; that<br>
&gt;is, anyone who keeps programming long enough, and keeps making more<br>
&gt;and more complex and/or functional programs will, eventually,<br>
&gt;&quot;outgrow&quot; Toon Talk.<br>
&gt;<br>
<br>
<br>
The current version of ToonTalk has many limitations and shortcomings. Its<br>
ability to manipulate text strings is so-so. Its ability to do file I/O is<br>
minimal. There are no floating point numbers. It requires a large and slow<br>
programming environment to run programs. It currently is able to deal with<br>
user media only as BMP or WAV files. You can re-train robots but you can't<br>
edit their behavior. So, I would not try to build a web browser in ToonTalk.<br>
The only reasonable way ToonTalk could be used for CGI programming would be<br>
to build the program in ToonTalk and then use the Java translation on the<br>
server.<br>
<br>
&gt;if this conjecture is correct, I would be curious as to when/how you<br>
&gt;(Ken Kahn) would expect a child who kept &quot;doing more&quot; to &quot;outgrow&quot;<br>
&gt;Toon Talk.&nbsp; I would also be curious as to where you would recomend<br>
&gt;they go when this happened.&nbsp; perhaps another way of putting this is:<br>
&gt;you clearly view Toon Talk as a &quot;first step&quot; in a progression... what<br>
&gt;else do you see in that progression?<br>
&gt;<br>
Maybe in a few years there will be a ToonTalk Pro or ToonTalk version 5.0<br>
(currently at 1.04) which won't be outgrown. In other words, I don't see any<br>
reason to outgrow the core ideas of ToonTalk computation model and<br>
programming environment. It is only the current implementation that might be<br>
outgrown.<br>
<br>
If a child mastered ToonTalk and wanted to do things it currently can't do,<br>
I guess that Java is the best next step. I see ToonTalk's ability to produce<br>
the Java equivalent of whatever a child has made as a bridge or stepping<br>
stone to make the transition to Java a bit easier.<br>
<br>
&gt;<br>
&gt;part of the reason I'm asking this is the same reason I started<br>
&gt;following this newsgroup a couple weeks ago.&nbsp; I'm trying to understand<br>
&gt;this amorpheous concept of &quot;easy&quot; as applied to computer use and<br>
&gt;programming.&nbsp; also, can you name any other environments which share<br>
&gt;what you believe to be Toon Talk's most essential features?<br>
&gt;<br>
<br>
This is a really good question and I hope others try to answer it as well.<br>
One thing I've observed with kids and ToonTalk is that they very quickly<br>
learn the language primitives. Where they get stuck is they lack design<br>
skills - they know no programming techniques. This is how I feel when I play<br>
with Lego Technic gears. I understand how gears work but I can't build a<br>
very good Lego car.<br>
<br>
There are many languages that share ToonTalk's model of computation -<br>
Concurrent Prolog, Parlog, Guarded Horn Clauses, Strand, KL1, OC, Herbrand,<br>
Janus, Linear Janus, and Oz. I think these languages aren't better known<br>
because programmers have found them hard to learn. I suspect this is mostly<br>
because programmers have already learned a very different way of thinking<br>
about programming.<br>
<br>
There are no other environments that I know of that enable you to do general<br>
purpose programming within a game-like world. Robot Odyssey and Rocky's<br>
Boots (popular games from the early 1980s) let you express circuits and<br>
boolean computations in a game-like world. Stagecast Creator (formerly known<br>
as KidSim and Cocoa) makes it easy for kids to express some kinds of<br>
programs as picture re-write rules.<br>
<br>
&gt;<br>
&gt;...so I figured out that consistency is an important part of something<br>
&gt;being &quot;easy&quot;, but I know there's other things.<br>
&gt;<br>
<br>
I think a good learnable language should have a small but powerful kernel.<br>
E.g. ToonTalk or Scheme. You then get consistency because most everything<br>
else is built upon the kernel.<br>
&gt;<br>
&gt;BASIC (is that a bad word here?), as I learned it on the apple II, is<br>
&gt;a very consistent language.&nbsp; it is also &quot;easy&quot; to grasp at first, but<br>
&gt;once a programmer starts trying to do anything requiring more than a<br>
&gt;couple thought processes to execute, he finds himself in spaghetti<br>
&gt;code.<br>
<br>
Back in the 1970s and early 1980s BASIC was a bad word in the Logo<br>
community. But I don't know how the newer, better implementations of Basic<br>
are viewed today. Visual Basic seems pretty reasonable these days - it has<br>
recursive procedures, reasonable variable names, etc.<br>
<br>
&gt;<br>
&gt;C++, like perl, has all sorts of &quot;magic&quot; in it... the same expression<br>
&gt;can mean all sorts of things depending on the context...<br>
&gt;<br>
&gt;I think C is a better first language than C++ because it has so much<br>
&gt;less &quot;magic&quot;,<br>
<br>
Interesting. By &quot;magic&quot; do you mean that the underlying mechanism is complex<br>
and farther from the hardware? Would you argue against Java in the same way?<br>
<br>
Best,<br>
<br>
-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)<br>
</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From <a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a>:</font></p>

<p><font face="Comic Sans MS">&quot;Ken Kahn&quot; &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>&gt; writes:<br>
&gt; Maybe in a few years there will be a ToonTalk Pro or ToonTalk version 5.0<br>
&gt; (currently at 1.04) which won't be outgrown. In other words, I don't see any<br>
&gt; reason to outgrow the core ideas of ToonTalk computation model and<br>
&gt; programming environment. It is only the current implementation that might be<br>
&gt; outgrown.<br>
<br>
ever plan to make it self hosting?&nbsp; :-)<br>
<br>
<br>
[snip]<br>
&gt; One thing I've observed with kids and ToonTalk is that they very quickly<br>
&gt; learn the language primitives. Where they get stuck is they lack design<br>
&gt; skills - they know no programming techniques. This is how I feel when I play<br>
&gt; with Lego Technic gears. I understand how gears work but I can't build a<br>
&gt; very good Lego car.<br>
<br>
isn't that the way it is with anyone first learning to program?&nbsp; I<br>
remember an assignment from my first programming course back in my<br>
college days.&nbsp; we were to write a program to ask the user to type in<br>
words and the program would tell the user if each word was a<br>
palindrome or not.&nbsp; it was the first assignment most of the students<br>
had a problem with.&nbsp; to follow the lego example, it was the first time<br>
they had to build something rather than prove they knew which part of<br>
one lego fit into which part of the next.&nbsp; the course was in C, and<br>
everyone knew how to use loops, char arrays, conditionals, and so on,<br>
but they didn't have any idea how to start putting them together.<br>
this is the only intro to programming course I've ever observed, not<br>
being a teacher myself, so my sample is a bit small, but I would not<br>
be surprised to hear that what you describe is a common pattern.<br>
<br>
&gt; There are many languages that share ToonTalk's model of computation -<br>
&gt; Concurrent Prolog, Parlog, Guarded Horn Clauses, Strand, KL1, OC, Herbrand,<br>
&gt; Janus, Linear Janus, and Oz. I think these languages aren't better known<br>
&gt; because programmers have found them hard to learn. I suspect this is mostly<br>
&gt; because programmers have already learned a very different way of thinking<br>
&gt; about programming.<br>
<br>
could you provide any urls or book recomendations?&nbsp; as a professional<br>
problem solver, and a human being in general, I am always trying to<br>
find new ways to look at problems.<br>
<br>
&gt; There are no other environments that I know of that enable you to do general<br>
&gt; purpose programming within a game-like world. Robot Odyssey and Rocky's<br>
&gt; Boots (popular games from the early 1980s) let you express circuits and<br>
&gt; boolean computations in a game-like world. Stagecast Creator (formerly known<br>
&gt; as KidSim and Cocoa) makes it easy for kids to express some kinds of<br>
&gt; programs as picture re-write rules.<br>
<br>
one hypothesis that bounced around in my head was that logo wasn't<br>
actually any easier than lisp.&nbsp; maybe it's just that since it has such<br>
a short initial &quot;start typing&quot; to &quot;see something cool&quot; curve, kids are<br>
more willing to put the effort into learning logo since they receive<br>
encouragement of a sort early on.<br>
<br>
&gt; I think a good learnable language should have a small but powerful kernel.<br>
&gt; E.g. ToonTalk or Scheme. You then get consistency because most everything<br>
&gt; else is built upon the kernel.<br>
<br>
I've heard this about scheme many times before, which is why I've<br>
recently begun reading the standard.&nbsp; one of the things that I've<br>
found annoying about elisp is remembering which builtins are special<br>
forms/macros, and which ones are normal functions.&nbsp; that is, if I want<br>
to supply a function with a symbol, do I quote the symbol, or not?<br>
for instance, (setq hi &quot;there&quot;) is the same as (set 'hi &quot;there&quot;).<br>
<br>
&gt; &gt;C++, like perl, has all sorts of &quot;magic&quot; in it... the same expression<br>
&gt; &gt;can mean all sorts of things depending on the context...<br>
&gt; &gt;<br>
&gt; &gt;I think C is a better first language than C++ because it has so much<br>
&gt; &gt;less &quot;magic&quot;,<br>
<br>
&gt; Interesting. By &quot;magic&quot; do you mean that the underlying mechanism is
complex<br>
&gt; and farther from the hardware? Would you argue against Java in the same way?<br>
<br>
by magic, I mean weird, special case syntactic sugar.&nbsp; I'm using it in<br>
the sense that one would say &quot;in perl, &lt;&gt; as the only condition in a<br>
while loop is magic, sinse it does all these special things.&quot;<br>
...things which just don't make sense until you've had enough real<br>
world experience to see why they are valuable...<br>
<br>
considder the difference between:<br>
cout &lt;&lt; 2 &lt;&lt; 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==&nbsp;&nbsp;&nbsp; (
cout.operator&lt;&lt;( 2 ) ).operator&lt;&lt;( 2 );<br>
=&gt; 23<br>
and:<br>
cout &lt;&lt; (2 &lt;&lt; 3);&nbsp;&nbsp;&nbsp; == &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout.operator&lt;&lt;( 2 &lt;&lt; 3 );<br>
=&gt; 16<br>
<br>
am I the only one who finds this a little bit screwy?<br>
<br>
properly used, operator overloading, function overloading, and various<br>
other features of C++ can be great.&nbsp; while I would recomend C++ for<br>
certain types of large projects, when used by knowledgable and highly<br>
competent programmers, I wouldn't currently recomend it as a first<br>
language.&nbsp; but then again, I'm still forming my opinions on the<br>
subject, and reserve the right to change my mind at any time.<br>
<br>
as far as java goes, the last time I touched it was when it was brand<br>
new, and while I was impressed with many of the ideas in the language,<br>
the implimentation kept crashing on everything I wrote which was<br>
longer than 50 lines or so, so I never got really intimate with it...<br>
<br>
giving it another try has been somewhere near the middle of my todo<br>
list for a while now.<br>
<br>
thanks for the thoughtful responses,<br>
andru</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>
<a href="mailto:luvisi@andru.sonoma.edu">

<p><font face="Comic Sans MS">luvisi@andru.sonoma.edu</a> wrote in message ...<br>
&gt;&gt; There are many languages that share ToonTalk's model of computation -<br>
&gt;&gt; Concurrent Prolog, Parlog, Guarded Horn Clauses, Strand, KL1, OC,<br>
Herbrand,<br>
&gt;&gt; Janus, Linear Janus, and Oz.<br>
<br>
&gt;could you provide any urls or book recomendations?&nbsp; as a professional<br>
&gt;problem solver, and a human being in general, I am always trying to<br>
&gt;find new ways to look at problems.<br>
&gt;<br>
<br>
Very good but theoretical:<br>
Concurrent Constraint Programming (Acm Doctoral Dissertation Awards)<br>
Vijay A. Saraswat / Hardcover / Published 1993<br>
Our Price: $55.00 (Special Order)<br>
Read more about this title...<br>
<br>
Haven't read it but I should. Looks good:<br>
Objects for Concurrent Constraint Programming (Kluwer International Series<br>
in Engineering and Computer Science, 426)<br>
Martin Henz / Hardcover / Published 1997<br>
<br>
A bit old but a very good collection of papers:<br>
Concurrent Prolog : Collected Papers (Logic Programming Series)<br>
Ehud Shapiro(Editor) / Hardcover / Published 1988<br>
<br>
&gt;<br>
&gt;considder the difference between:<br>
&gt;cout &lt;&lt; 2 &lt;&lt; 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==&nbsp;&nbsp;&nbsp; (
cout.operator&lt;&lt;( 2 ) ).operator&lt;&lt;( 2 );<br>
&gt;=&gt; 23<br>
&gt;and:<br>
&gt;cout &lt;&lt; (2 &lt;&lt; 3);&nbsp;&nbsp;&nbsp; == &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout.operator&lt;&lt;( 2 &lt;&lt; 3 );<br>
&gt;=&gt; 16<br>
&gt;<br>
&gt;am I the only one who finds this a little bit screwy?<br>
&gt;<br>
<br>
<br>
Seeing this makes me glad that syntax errors and confusions are a non-issue<br>
for ToonTalk.<br>
<br>
Best,<br>
<br>
-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)<br>
<br>
</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Brian Harvey:</font></p>
<a href="mailto:luvisi@andru.sonoma.edu">

<p><font face="Comic Sans MS">luvisi@andru.sonoma.edu</a> writes:<br>
&gt;conjecture: Toon Talk is not capable of serving as a development<br>
&gt;environment for all applications one will ever wish to create.&nbsp; that<br>
&gt;is, anyone who keeps programming long enough, and keeps making more<br>
&gt;and more complex and/or functional programs will, eventually,<br>
&gt;&quot;outgrow&quot; Toon Talk.<br>
<br>
Ken's answer to this was about the theoretical capabilities of the<br>
program, but what drives me crazy in TT is the user interface -- the<br>
fact that when you want to add two numbers you have to sit there for<br>
several seconds watching this funny-the-first-time animation of the<br>
rat with the hammer.&nbsp; The fact that I can't get the sorcerer's<br>
apprentice vacuum cleaner to stop deleting things!&nbsp; (I mean, I can<br>
eventually, but not until it's eaten three things I wanted.)&nbsp; Stuff<br>
like that.&nbsp; I bet kids outgrow that before they outgrow the set of<br>
problems TT can program.<br>
<br>
&gt;...so I figured out that consistency is an important part of something<br>
&gt;being &quot;easy&quot;, but I know there's other things.<br>
<br>
There's actually a good deal of disagreement among Logo people about<br>
the consistency question.&nbsp; The early MIT Logos (whence Terrapin Logo<br>
and friends) have a BASIC-style IF/THEN special form.&nbsp; At LCSI we<br>
decided to eliminate all special forms except TO; our IF is an ordinary<br>
procedure whose arguments must be quoted to avoid premature evaluation.<br>
MIT: IF 2=3 THEN PRINT &quot;HELLO<br>
LCSI: IF 2=3 [PRINT &quot;HELLO]<br>
I like the LCSI way better because it's more uniform and therefore<br>
easier to model, but I'm not sure it's &quot;easier&quot; for beginners.&nbsp; It<br>
would be if the beginners were taught the model of applicative order<br>
evaluation, but they're not; they're taught &quot;just remember to put<br>
brackets around the thing you want IF to run conditionally.&quot;&nbsp; So it<br>
can *seem* to be *less* uniform!<br>
<br>
Aside from obvious dreadful mistakes, like the fact that STATIC means<br>
four, count them, four completely unrelated things in C++, I've come<br>
to believe that there's no such thing as easy or hard language features;<br>
it all depends on what you're used to.&nbsp; Well, maybe except for call/cc<br>
in Scheme... that's hard... but when it comes to choosing a paradigm,<br>
functional is easiest if you're accustomed to doing math, but not<br>
otherwise, and I suspect some similar thing is true about concurrent<br>
programming.<br>
<br>
&gt;&nbsp; frankly, [Logo] just reminded me of<br>
&gt;elisp (the only lisp dialect I am very familiar with, though I know a<br>
&gt;*teeny* bit of scheme) with some different names, and '(...) replaced<br>
&gt;with [...] and '... replaced with &quot;... .<br>
&gt;all the same concepts... recursion, variables, itteration via tail<br>
&gt;recursion, minus things like non-argument local variables.<br>
<br>
I think Apple Logo II has LOCAL, doesn't it?<br>
<br>
But otherwise, indeed, Logo is basically Lisp.&nbsp; They left out the<br>
parentheses because they scare people; they added infix arithmetic.<br>
At the time Logo was designed, dynamic scope was standard for Lisp<br>
interpreters, so we didn't even have to think about that, although<br>
even today I stand by that choice for Logo.<br>
<br>
&gt;-&gt; what is it about logo (or any other language) that is supposed to make<br>
&gt;-&gt; it &quot;easy&quot;, and good as a first language?<br>
<br>
At the time, we argued that lists are more natural than arrays, because<br>
you don't have to count how big to make them, and you don't have to<br>
introduce index variables that really aren't relevant to your problem.<br>
Recursion is (we said) more natural than things like FOR loops,<br>
especially if you think in terms of little people (so that you focus<br>
on invocations, rather than on procedures).&nbsp; <br>
<br>
Also, a lot of design effort went into the error messages.&nbsp; It was<br>
particularly easy to make fun of BASIC back then, which mostly said<br>
SYNTAX ERROR no matter what you did wrong.&nbsp; We had arguments about<br>
whether &quot;I don't know how to XXX&quot; is better or worse than &quot;you don't<br>
say how to XXX&quot; (that is, is it good or bad to personify the computer),<br>
and then there was Paul Goldenberg's brilliant idea to put an extra<br>
space in, as in &quot;You don't say how&nbsp; to XXX&quot; to help remind the user<br>
that TO is what you use to fix it!</font></p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p><font face="Comic Sans MS">From Ken Kahn:</font></p>

<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:74cgpg$4sr$1@agate.berkeley.edu">74cgpg$4sr$1@agate.berkeley.edu</a>&gt;...<br>
<br>
&gt;Ken's answer to this was about the theoretical capabilities of the<br>
&gt;program, but what drives me crazy in TT is the user interface -- the<br>
&gt;fact that when you want to add two numbers you have to sit there for<br>
&gt;several seconds watching this funny-the-first-time animation of the<br>
&gt;rat with the hammer.&nbsp; The fact that I can't get the sorcerer's<br>
&gt;apprentice vacuum cleaner to stop deleting things!&nbsp; (I mean, I can<br>
&gt;eventually, but not until it's eaten three things I wanted.)&nbsp; Stuff<br>
&gt;like that.&nbsp; I bet kids outgrow that before they outgrow the set of<br>
&gt;problems TT can program.<br>
&gt;<br>
Kids adapt rather than outgrow. And there are good reasons why the interface<br>
is the way it is. If you had to wait every time for the mouse with a hammer,<br>
then I would agree with you. But ToonTalk isn't just a concurrent<br>
programming system, it is a concurrent programming environment as well. You<br>
can drop a number on a number and start working on the next thing, confident<br>
that the mouse will add them together while you are doing the next thing.<br>
There was a time when the vacuum cleaner vacuumed up one thing when you<br>
turned him on. But real vacuums stay on until you turn them off. And the<br>
bike pump has an even stronger need to be on until you turn him off. You<br>
want to slowly change the dimensions of something until it is the way you<br>
want and then stop pumping.<br>
<br>
The only kid who I've heard complain about the interface was 14 years old.<br>
And you were there last month, when a 9 year old at the BayCHI Kids meeting<br>
walked up to ToonTalk &quot;cold&quot; and did very well with it without help.<br>
<br>
Best,<br>
<br>
-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)</font><br>
</p>

<p><font face="Comic Sans MS"><img SRC="../rainbow.gif" width="623" height="6"></font></p>

<p id="DontRead" align="center"><small><font face="Comic Sans MS">
<a href="toontalk.htm" style="color: blue; text-decoration: underline; text-underline: single">home</a> | 
<a href="search.htm" style="color: blue; text-decoration: underline; text-underline: single">search</a> | 
<a href="buy.htm" style="color: blue; text-decoration: underline; text-underline: single">purchase</a> | 
<a href="doc.htm" style="color: blue; text-decoration: underline; text-underline: single">manual</a>
| 
<a href="whatsnew.htm" style="color: blue; text-decoration: underline; text-underline: single">news</a> | 
<a href="infodesk.htm" style="color: blue; text-decoration: underline; text-underline: single">info</a> | 
<a href="games.htm" style="color: blue; text-decoration: underline; text-underline: single">games</a>
| 
<a href="faq.htm" style="color: blue; text-decoration: underline; text-underline: single">faq</a> | 
<a href="support.htm" style="color: blue; text-decoration: underline; text-underline: single">support</a> | 
<a href="free.htm" style="color: blue; text-decoration: underline; text-underline: single">downloads</a>
| 
<a href="endorse.htm" style="color: blue; text-decoration: underline; text-underline: single">endorsements</a> | 
<a href="press.htm" style="color: blue; text-decoration: underline; text-underline: single">press</a> | 
<a href="address.htm" style="color: blue; text-decoration: underline; text-underline: single">contact us</a></font></small></p>

<p align="center"><font size="5" face="Comic Sans MS"><b>&nbsp;</b></font><b><font FACE="Comic Sans MS" SIZE="5">

<object id="AgentControl" codeBase="#VERSION=2,0,0,0" classid="clsid:D45FD31B-5C6E-11D1-9EC1-00C04FD7081F" VIEWASTEXT>
</object>
<script language="javascript" src="../agent.js"></script>
<script language="javascript" src="strings.js">
</script>
<script language="JavaScript" event="Click(CharacterID, Button, Shift, X, Y)" for="AgentControl"> 

<!-- 

reactToAgentClicked(CharacterID, Button, Shift, X, Y); 

--> </script>
<script language="JavaScript" event="IdleStart(CharacterID)" for="AgentControl"> 

<!-- 

idleAgent(CharacterID); 

--> 

</script>
<input onclick="agentStart()" type="image" alt="Peedy can read this page for you." src="../reading.gif" name="Image1" width="58" height="51"></font></b></p>

<p>&nbsp;</p>
</body>
</html>